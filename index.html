<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FAANG Flashcards ‚Äî LeetCode Interview Prep</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Syne:wght@400;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #12121a;
    --surface2: #1a1a26;
    --border: #2a2a3a;
    --accent: #00ff88;
    --accent2: #ff6b6b;
    --accent3: #6b8cff;
    --accent4: #ffcc44;
    --text: #e8e8f0;
    --muted: #6b6b80;
    --card-h: 400px;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Syne', sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Animated grid background */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image:
      linear-gradient(rgba(0,255,136,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,255,136,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
    z-index: 0;
  }

  header {
    position: relative;
    z-index: 10;
    padding: 3rem 2rem 2rem;
    text-align: center;
    border-bottom: 1px solid var(--border);
  }

  .header-badge {
    display: inline-block;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    letter-spacing: 0.2em;
    color: var(--accent);
    border: 1px solid var(--accent);
    padding: 0.25rem 0.75rem;
    margin-bottom: 1rem;
    text-transform: uppercase;
  }

  h1 {
    font-size: clamp(2rem, 5vw, 3.5rem);
    font-weight: 800;
    line-height: 1;
    letter-spacing: -0.03em;
    margin-bottom: 0.5rem;
  }

  h1 span { color: var(--accent); }

  .subtitle {
    font-family: 'JetBrains Mono', monospace;
    color: var(--muted);
    font-size: 0.85rem;
  }

  /* Stats bar */
  .stats-bar {
    display: flex;
    justify-content: center;
    gap: 2rem;
    padding: 1rem 2rem;
    border-bottom: 1px solid var(--border);
    flex-wrap: wrap;
    position: relative;
    z-index: 10;
  }

  .stat {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.8rem;
    color: var(--muted);
  }

  .stat strong { color: var(--text); font-size: 1rem; }

  /* Filters */
  .filters {
    position: relative;
    z-index: 10;
    padding: 1.5rem 2rem;
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    align-items: center;
    border-bottom: 1px solid var(--border);
    background: rgba(18,18,26,0.8);
    backdrop-filter: blur(10px);
    position: sticky;
    top: 0;
    z-index: 100;
  }

  .filter-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    letter-spacing: 0.1em;
    color: var(--muted);
    text-transform: uppercase;
    white-space: nowrap;
  }

  .filter-group {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
    align-items: center;
  }

  .filter-btn {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    padding: 0.35rem 0.8rem;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--muted);
    cursor: pointer;
    transition: all 0.15s;
    letter-spacing: 0.05em;
  }

  .filter-btn:hover { border-color: var(--accent); color: var(--accent); }
  .filter-btn.active { background: var(--accent); color: var(--bg); border-color: var(--accent); font-weight: 700; }

  .filter-btn.diff-easy.active { background: #00cc66; border-color: #00cc66; }
  .filter-btn.diff-medium.active { background: #ffaa00; border-color: #ffaa00; color: #000; }
  .filter-btn.diff-hard.active { background: #ff4444; border-color: #ff4444; }

  .divider { width: 1px; height: 24px; background: var(--border); }

  .search-wrap {
    margin-left: auto;
    position: relative;
  }

  #search {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.8rem;
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 0.4rem 0.8rem 0.4rem 2rem;
    width: 200px;
    outline: none;
    transition: border-color 0.2s;
  }

  #search:focus { border-color: var(--accent); }
  #search::placeholder { color: var(--muted); }

  .search-icon {
    position: absolute;
    left: 0.6rem;
    top: 50%;
    transform: translateY(-50%);
    color: var(--muted);
    font-size: 0.8rem;
  }

  /* Progress */
  .progress-bar-wrap {
    padding: 0.75rem 2rem;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 1rem;
    position: relative;
    z-index: 10;
  }

  .progress-track {
    flex: 1;
    height: 4px;
    background: var(--border);
    position: relative;
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), var(--accent3));
    transition: width 0.4s ease;
    width: 0%;
  }

  .progress-text {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
    color: var(--muted);
    white-space: nowrap;
  }

  .reset-btn {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    padding: 0.25rem 0.6rem;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--muted);
    cursor: pointer;
    transition: all 0.15s;
  }

  .reset-btn:hover { border-color: var(--accent2); color: var(--accent2); }

  /* Main grid */
  main {
    position: relative;
    z-index: 10;
    padding: 2rem;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
    gap: 1.5rem;
    max-width: 1600px;
    margin: 0 auto;
  }

  /* Flashcard */
  .card-wrap {
    perspective: 1200px;
    height: var(--card-h);
  }

  .card-wrap.hidden { display: none; }

  .card {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
    transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
    cursor: pointer;
  }

  .card.flipped { transform: rotateY(180deg); }

  .card-front, .card-back {
    position: absolute;
    inset: 0;
    backface-visibility: hidden;
    border: 1px solid var(--border);
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    transition: border-color 0.2s;
    overflow: hidden;
  }

  .card-front {
    background: var(--surface);
  }

  .card-back {
    background: var(--surface2);
    transform: rotateY(180deg);
  }

  .card-wrap:hover .card-front,
  .card-wrap:hover .card-back {
    border-color: var(--accent);
  }

  .card-wrap.mastered .card-front,
  .card-wrap.mastered .card-back {
    border-color: var(--accent) !important;
    box-shadow: 0 0 20px rgba(0,255,136,0.1);
  }

  /* Card header */
  .card-meta {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
  }

  .card-num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    color: var(--muted);
  }

  .tag {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.65rem;
    padding: 0.15rem 0.5rem;
    border: 1px solid;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .tag-topic { border-color: var(--accent3); color: var(--accent3); }
  .tag-easy { border-color: #00cc66; color: #00cc66; }
  .tag-medium { border-color: #ffaa00; color: #ffaa00; }
  .tag-hard { border-color: #ff4444; color: #ff4444; }

  .lc-link {
    margin-left: auto;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.65rem;
    color: var(--muted);
    text-decoration: none;
    border: 1px solid var(--border);
    padding: 0.15rem 0.4rem;
    transition: all 0.15s;
  }

  .lc-link:hover { color: var(--accent); border-color: var(--accent); }

  /* Card title */
  .card-title {
    font-size: 1.2rem;
    font-weight: 700;
    letter-spacing: -0.02em;
    margin-bottom: 0.75rem;
    line-height: 1.2;
  }

  .card-question {
    font-size: 0.85rem;
    color: #b0b0c0;
    line-height: 1.6;
    flex: 1;
    overflow: auto;
  }

  .card-hint {
    margin-top: 1rem;
    padding: 0.75rem;
    background: rgba(107, 140, 255, 0.08);
    border-left: 2px solid var(--accent3);
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    color: var(--accent3);
    line-height: 1.5;
  }

  .card-hint-label {
    font-size: 0.65rem;
    color: var(--muted);
    letter-spacing: 0.1em;
    text-transform: uppercase;
    margin-bottom: 0.3rem;
  }

  /* Flip indicator */
  .flip-hint {
    margin-top: 1rem;
    text-align: center;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.65rem;
    color: var(--muted);
    letter-spacing: 0.1em;
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.4; }
    50% { opacity: 1; }
  }

  /* Back side - code */
  .back-header {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    color: var(--accent);
    letter-spacing: 0.1em;
    text-transform: uppercase;
    margin-bottom: 0.75rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .back-header::after {
    content: '';
    flex: 1;
    height: 1px;
    background: var(--border);
  }

  pre {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    line-height: 1.6;
    color: #c8c8e0;
    overflow: auto;
    flex: 1;
    white-space: pre;
  }

  /* Syntax highlight */
  .kw { color: #ff79c6; }
  .fn { color: #50fa7b; }
  .cm { color: #6272a4; font-style: italic; }
  .st { color: #f1fa8c; }
  .nm { color: #bd93f9; }

  /* Card footer actions */
  .card-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 1rem;
  }

  .action-btn {
    flex: 1;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    padding: 0.4rem;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--muted);
    cursor: pointer;
    transition: all 0.15s;
    letter-spacing: 0.05em;
  }

  .action-btn.mastered-btn:hover { border-color: var(--accent); color: var(--accent); }
  .action-btn.mastered-btn.active { background: var(--accent); color: var(--bg); border-color: var(--accent); }
  .action-btn.flip-btn:hover { border-color: var(--accent3); color: var(--accent3); }

  /* Empty state */
  #empty {
    display: none;
    position: relative;
    z-index: 10;
    text-align: center;
    padding: 5rem 2rem;
    font-family: 'JetBrains Mono', monospace;
    color: var(--muted);
  }

  #empty .empty-icon { font-size: 3rem; margin-bottom: 1rem; opacity: 0.3; }

  /* Scroll to top */
  .scroll-top {
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    width: 44px;
    height: 44px;
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--muted);
    cursor: pointer;
    font-size: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    transition: all 0.2s;
    opacity: 0;
    pointer-events: none;
  }

  .scroll-top.visible { opacity: 1; pointer-events: all; }
  .scroll-top:hover { border-color: var(--accent); color: var(--accent); }

  /* Card entrance animation */
  .card-wrap { animation: fadeUp 0.3s ease both; }

  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }

  @media (max-width: 600px) {
    main { padding: 1rem; grid-template-columns: 1fr; }
    .filters { padding: 1rem; }
    .search-wrap { width: 100%; }
    #search { width: 100%; }
  }
</style>
</head>
<body>

<header>
  <div class="header-badge">// FAANG Interview Prep</div>
  <h1>LeetCode <span>Flashcards</span></h1>
  <p class="subtitle">Top 100 Questions ¬∑ Python Solutions ¬∑ Click to Flip</p>
</header>

<div class="stats-bar">
  <div class="stat"><strong id="total-count">100</strong> total</div>
  <div class="stat"><strong id="visible-count">100</strong> showing</div>
  <div class="stat"><strong id="mastered-count">0</strong> mastered</div>
  <div class="stat" style="color: #00cc66"><strong id="easy-count">0</strong> easy</div>
  <div class="stat" style="color: #ffaa00"><strong id="med-count">0</strong> medium</div>
  <div class="stat" style="color: #ff4444"><strong id="hard-count">0</strong> hard</div>
</div>

<div class="filters">
  <span class="filter-label">Topic:</span>
  <div class="filter-group" id="topic-filters">
    <button class="filter-btn active" data-topic="all">All</button>
    <button class="filter-btn" data-topic="Arrays">Arrays</button>
    <button class="filter-btn" data-topic="Binary Search">Binary Search</button>
    <button class="filter-btn" data-topic="Linked Lists">Linked Lists</button>
    <button class="filter-btn" data-topic="Trees">Trees</button>
    <button class="filter-btn" data-topic="Graphs">Graphs</button>
    <button class="filter-btn" data-topic="Dynamic Programming">DP</button>
    <button class="filter-btn" data-topic="Heap">Heap</button>
    <button class="filter-btn" data-topic="Backtracking">Backtracking</button>
    <button class="filter-btn" data-topic="Trie">Trie</button>
    <button class="filter-btn" data-topic="Sliding Window">Sliding Window</button>
  </div>

  <div class="divider"></div>
  <span class="filter-label">Difficulty:</span>
  <div class="filter-group" id="diff-filters">
    <button class="filter-btn active" data-diff="all">All</button>
    <button class="filter-btn diff-easy" data-diff="Easy">Easy</button>
    <button class="filter-btn diff-medium" data-diff="Medium">Medium</button>
    <button class="filter-btn diff-hard" data-diff="Hard">Hard</button>
  </div>

  <div class="divider"></div>
  <span class="filter-label">Show:</span>
  <div class="filter-group" id="status-filters">
    <button class="filter-btn active" data-status="all">All</button>
    <button class="filter-btn" data-status="mastered">Mastered</button>
    <button class="filter-btn" data-status="unmastered">Unmastered</button>
  </div>

  <div class="search-wrap">
    <span class="search-icon">üîç</span>
    <input type="text" id="search" placeholder="Search questions...">
  </div>
</div>

<div class="progress-bar-wrap">
  <span class="progress-text">Progress</span>
  <div class="progress-track"><div class="progress-fill" id="progress-fill"></div></div>
  <span class="progress-text" id="progress-label">0 / 100</span>
  <button class="reset-btn" onclick="resetAll()">Reset All</button>
</div>

<main id="card-grid"></main>
<div id="empty"><div class="empty-icon">‚óª</div><div>No cards match your filters.</div></div>
<button class="scroll-top" id="scrollTop" onclick="window.scrollTo({top:0,behavior:'smooth'})">‚Üë</button>

<script>
const CARDS = [
  // ‚îÄ‚îÄ Arrays & Strings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  {
    id: 1, lc: 1, title: "Two Sum",
    topic: "Arrays", difficulty: "Easy",
    question: "Given an array of integers nums and an integer target, return indices of the two numbers that add up to target. You may assume that each input would have exactly one solution.",
    hint: "Use a hash map to store complements. O(n) time.",
    code: `<span class="kw">def</span> <span class="fn">twoSum</span>(nums, target):
    seen = {}
    <span class="kw">for</span> i, n <span class="kw">in</span> <span class="fn">enumerate</span>(nums):
        diff = target - n
        <span class="kw">if</span> diff <span class="kw">in</span> seen:
            <span class="kw">return</span> [seen[diff], i]
        seen[n] = i`
  },
  {
    id: 2, lc: 121, title: "Best Time to Buy and Sell Stock",
    topic: "Arrays", difficulty: "Easy",
    question: "Given an array prices where prices[i] is the price on day i, find the maximum profit by buying on one day and selling on a later day.",
    hint: "Track min price seen so far, update max profit each step.",
    code: `<span class="kw">def</span> <span class="fn">maxProfit</span>(prices):
    min_p, max_p = <span class="fn">float</span>(<span class="st">'inf'</span>), <span class="nm">0</span>
    <span class="kw">for</span> p <span class="kw">in</span> prices:
        min_p = <span class="fn">min</span>(min_p, p)
        max_p = <span class="fn">max</span>(max_p, p - min_p)
    <span class="kw">return</span> max_p`
  },
  {
    id: 3, lc: 217, title: "Contains Duplicate",
    topic: "Arrays", difficulty: "Easy",
    question: "Given an integer array nums, return true if any value appears at least twice in the array, and false if every element is distinct.",
    hint: "Compare length of set vs array.",
    code: `<span class="kw">def</span> <span class="fn">containsDuplicate</span>(nums):
    <span class="kw">return</span> <span class="fn">len</span>(nums) != <span class="fn">len</span>(<span class="fn">set</span>(nums))`
  },
  {
    id: 4, lc: 238, title: "Product of Array Except Self",
    topic: "Arrays", difficulty: "Medium",
    question: "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all elements of nums except nums[i]. Must run in O(n) without division.",
    hint: "Two passes: prefix products left-to-right, then suffix right-to-left.",
    code: `<span class="kw">def</span> <span class="fn">productExceptSelf</span>(nums):
    n = <span class="fn">len</span>(nums)
    res = [<span class="nm">1</span>] * n
    pre = <span class="nm">1</span>
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(n):
        res[i] = pre
        pre *= nums[i]
    suf = <span class="nm">1</span>
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(n - <span class="nm">1</span>, -<span class="nm">1</span>, -<span class="nm">1</span>):
        res[i] *= suf
        suf *= nums[i]
    <span class="kw">return</span> res`
  },
  {
    id: 5, lc: 53, title: "Maximum Subarray",
    topic: "Arrays", difficulty: "Medium",
    question: "Given an integer array nums, find the contiguous subarray with the largest sum and return its sum. (Kadane's Algorithm)",
    hint: "Kadane's: keep running sum, reset if negative.",
    code: `<span class="kw">def</span> <span class="fn">maxSubArray</span>(nums):
    cur = best = nums[<span class="nm">0</span>]
    <span class="kw">for</span> n <span class="kw">in</span> nums[<span class="nm">1</span>:]:
        cur = <span class="fn">max</span>(n, cur + n)
        best = <span class="fn">max</span>(best, cur)
    <span class="kw">return</span> best`
  },
  {
    id: 6, lc: 152, title: "Maximum Product Subarray",
    topic: "Arrays", difficulty: "Medium",
    question: "Given an integer array nums, find the contiguous subarray that has the largest product and return the product.",
    hint: "Track both max and min (negatives can flip). Update result each step.",
    code: `<span class="kw">def</span> <span class="fn">maxProduct</span>(nums):
    res = mx = mn = nums[<span class="nm">0</span>]
    <span class="kw">for</span> n <span class="kw">in</span> nums[<span class="nm">1</span>:]:
        mx, mn = (<span class="fn">max</span>(n, mx*n, mn*n),
                  <span class="fn">min</span>(n, mx*n, mn*n))
        res = <span class="fn">max</span>(res, mx)
    <span class="kw">return</span> res`
  },
  {
    id: 7, lc: 153, title: "Find Minimum in Rotated Sorted Array",
    topic: "Arrays", difficulty: "Medium",
    question: "Given a sorted array rotated between 1 and n times, find the minimum element in O(log n) time.",
    hint: "Binary search: compare mid to right boundary.",
    code: `<span class="kw">def</span> <span class="fn">findMin</span>(nums):
    l, r = <span class="nm">0</span>, <span class="fn">len</span>(nums) - <span class="nm">1</span>
    <span class="kw">while</span> l < r:
        m = (l + r) // <span class="nm">2</span>
        <span class="kw">if</span> nums[m] > nums[r]:
            l = m + <span class="nm">1</span>
        <span class="kw">else</span>:
            r = m
    <span class="kw">return</span> nums[l]`
  },
  {
    id: 8, lc: 33, title: "Search in Rotated Sorted Array",
    topic: "Arrays", difficulty: "Medium",
    question: "Given a rotated sorted array and a target, return the index of target or -1 if not found. Must run in O(log n).",
    hint: "Binary search with extra condition to determine which half is sorted.",
    code: `<span class="kw">def</span> <span class="fn">search</span>(nums, target):
    l, r = <span class="nm">0</span>, <span class="fn">len</span>(nums) - <span class="nm">1</span>
    <span class="kw">while</span> l <= r:
        m = (l + r) // <span class="nm">2</span>
        <span class="kw">if</span> nums[m] == target: <span class="kw">return</span> m
        <span class="kw">if</span> nums[l] <= nums[m]:
            <span class="kw">if</span> nums[l] <= target < nums[m]:
                r = m - <span class="nm">1</span>
            <span class="kw">else</span>: l = m + <span class="nm">1</span>
        <span class="kw">else</span>:
            <span class="kw">if</span> nums[m] < target <= nums[r]:
                l = m + <span class="nm">1</span>
            <span class="kw">else</span>: r = m - <span class="nm">1</span>
    <span class="kw">return</span> -<span class="nm">1</span>`
  },
  {
    id: 9, lc: 15, title: "3Sum",
    topic: "Arrays", difficulty: "Medium",
    question: "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j != k and nums[i] + nums[j] + nums[k] == 0. No duplicate triplets.",
    hint: "Sort, fix one element, then use two pointers for the rest.",
    code: `<span class="kw">def</span> <span class="fn">threeSum</span>(nums):
    nums.sort(); res = []
    <span class="kw">for</span> i, n <span class="kw">in</span> <span class="fn">enumerate</span>(nums):
        <span class="kw">if</span> i > <span class="nm">0</span> <span class="kw">and</span> n == nums[i-<span class="nm">1</span>]: <span class="kw">continue</span>
        l, r = i + <span class="nm">1</span>, <span class="fn">len</span>(nums) - <span class="nm">1</span>
        <span class="kw">while</span> l < r:
            s = n + nums[l] + nums[r]
            <span class="kw">if</span> s == <span class="nm">0</span>:
                res.append([n, nums[l], nums[r]])
                l += <span class="nm">1</span>
                <span class="kw">while</span> l < r <span class="kw">and</span> nums[l] == nums[l-<span class="nm">1</span>]: l += <span class="nm">1</span>
            <span class="kw">elif</span> s < <span class="nm">0</span>: l += <span class="nm">1</span>
            <span class="kw">else</span>: r -= <span class="nm">1</span>
    <span class="kw">return</span> res`
  },
  {
    id: 10, lc: 11, title: "Container With Most Water",
    topic: "Arrays", difficulty: "Medium",
    question: "Given n non-negative integers representing heights of vertical lines at positions 0..n-1, find two lines that together with the x-axis forms a container with the most water.",
    hint: "Two pointers from both ends. Move the shorter side inward.",
    code: `<span class="kw">def</span> <span class="fn">maxArea</span>(height):
    l, r = <span class="nm">0</span>, <span class="fn">len</span>(height) - <span class="nm">1</span>
    res = <span class="nm">0</span>
    <span class="kw">while</span> l < r:
        res = <span class="fn">max</span>(res, <span class="fn">min</span>(height[l], height[r]) * (r - l))
        <span class="kw">if</span> height[l] < height[r]: l += <span class="nm">1</span>
        <span class="kw">else</span>: r -= <span class="nm">1</span>
    <span class="kw">return</span> res`
  },
  {
    id: 11, lc: 42, title: "Trapping Rain Water",
    topic: "Arrays", difficulty: "Hard",
    question: "Given n non-negative integers representing elevation map widths of 1, compute how much water it can trap after raining.",
    hint: "Two pointers. Water at i = min(maxL, maxR) - height[i]. Process from the shorter side.",
    code: `<span class="kw">def</span> <span class="fn">trap</span>(height):
    l, r = <span class="nm">0</span>, <span class="fn">len</span>(height) - <span class="nm">1</span>
    ml, mr = height[l], height[r]
    res = <span class="nm">0</span>
    <span class="kw">while</span> l < r:
        <span class="kw">if</span> ml <= mr:
            l += <span class="nm">1</span>; ml = <span class="fn">max</span>(ml, height[l])
            res += ml - height[l]
        <span class="kw">else</span>:
            r -= <span class="nm">1</span>; mr = <span class="fn">max</span>(mr, height[r])
            res += mr - height[r]
    <span class="kw">return</span> res`
  },
  {
    id: 12, lc: 3, title: "Longest Substring Without Repeating Characters",
    topic: "Sliding Window", difficulty: "Medium",
    question: "Given a string s, find the length of the longest substring without repeating characters.",
    hint: "Sliding window with a set. Shrink from left when duplicate found.",
    code: `<span class="kw">def</span> <span class="fn">lengthOfLongestSubstring</span>(s):
    seen = <span class="fn">set</span>()
    l = res = <span class="nm">0</span>
    <span class="kw">for</span> r, c <span class="kw">in</span> <span class="fn">enumerate</span>(s):
        <span class="kw">while</span> c <span class="kw">in</span> seen:
            seen.discard(s[l]); l += <span class="nm">1</span>
        seen.add(c)
        res = <span class="fn">max</span>(res, r - l + <span class="nm">1</span>)
    <span class="kw">return</span> res`
  },
  {
    id: 13, lc: 424, title: "Longest Repeating Character Replacement",
    topic: "Sliding Window", difficulty: "Medium",
    question: "You can replace at most k characters. Find the length of the longest substring containing the same letter after replacements.",
    hint: "Sliding window. Window valid if (window_len - max_freq) <= k.",
    code: `<span class="kw">from</span> collections <span class="kw">import</span> defaultdict
<span class="kw">def</span> <span class="fn">characterReplacement</span>(s, k):
    count = defaultdict(<span class="fn">int</span>)
    l = mx = res = <span class="nm">0</span>
    <span class="kw">for</span> r, c <span class="kw">in</span> <span class="fn">enumerate</span>(s):
        count[c] += <span class="nm">1</span>
        mx = <span class="fn">max</span>(mx, count[c])
        <span class="kw">while</span> (r - l + <span class="nm">1</span>) - mx > k:
            count[s[l]] -= <span class="nm">1</span>; l += <span class="nm">1</span>
        res = <span class="fn">max</span>(res, r - l + <span class="nm">1</span>)
    <span class="kw">return</span> res`
  },
  {
    id: 14, lc: 76, title: "Minimum Window Substring",
    topic: "Sliding Window", difficulty: "Hard",
    question: "Given strings s and t, return the minimum window substring of s that contains all characters in t. Return empty string if no such window exists.",
    hint: "Sliding window with two freq maps. Expand right, shrink left when valid.",
    code: `<span class="kw">from</span> collections <span class="kw">import</span> Counter
<span class="kw">def</span> <span class="fn">minWindow</span>(s, t):
    need, have = Counter(t), {}
    formed, req = <span class="nm">0</span>, <span class="fn">len</span>(need)
    l, res, rlen = <span class="nm">0</span>, [-<span class="nm">1</span>,-<span class="nm">1</span>], <span class="fn">float</span>(<span class="st">'inf'</span>)
    <span class="kw">for</span> r, c <span class="kw">in</span> <span class="fn">enumerate</span>(s):
        have[c] = have.get(c, <span class="nm">0</span>) + <span class="nm">1</span>
        <span class="kw">if</span> c <span class="kw">in</span> need <span class="kw">and</span> have[c] == need[c]:
            formed += <span class="nm">1</span>
        <span class="kw">while</span> formed == req:
            <span class="kw">if</span> r - l + <span class="nm">1</span> < rlen:
                res, rlen = [l, r], r - l + <span class="nm">1</span>
            have[s[l]] -= <span class="nm">1</span>
            <span class="kw">if</span> s[l] <span class="kw">in</span> need <span class="kw">and</span> have[s[l]] < need[s[l]]:
                formed -= <span class="nm">1</span>
            l += <span class="nm">1</span>
    <span class="kw">return</span> s[res[<span class="nm">0</span>]:res[<span class="nm">1</span>]+<span class="nm">1</span>] <span class="kw">if</span> rlen != <span class="fn">float</span>(<span class="st">'inf'</span>) <span class="kw">else</span> <span class="st">""</span>`
  },
  {
    id: 15, lc: 242, title: "Valid Anagram",
    topic: "Arrays", difficulty: "Easy",
    question: "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
    hint: "Compare character frequency counts.",
    code: `<span class="kw">from</span> collections <span class="kw">import</span> Counter
<span class="kw">def</span> <span class="fn">isAnagram</span>(s, t):
    <span class="kw">return</span> Counter(s) == Counter(t)`
  },
  {
    id: 16, lc: 49, title: "Group Anagrams",
    topic: "Arrays", difficulty: "Medium",
    question: "Given an array of strings strs, group the anagrams together. You can return the answer in any order.",
    hint: "Sort each word as the hash key. Group by sorted key.",
    code: `<span class="kw">from</span> collections <span class="kw">import</span> defaultdict
<span class="kw">def</span> <span class="fn">groupAnagrams</span>(strs):
    d = defaultdict(<span class="fn">list</span>)
    <span class="kw">for</span> s <span class="kw">in</span> strs:
        d[<span class="fn">tuple</span>(<span class="fn">sorted</span>(s))].append(s)
    <span class="kw">return</span> <span class="fn">list</span>(d.values())`
  },
  {
    id: 17, lc: 20, title: "Valid Parentheses",
    topic: "Arrays", difficulty: "Easy",
    question: "Given a string s containing just '(', ')', '{', '}', '[' and ']', determine if the input string is valid (properly opened and closed in correct order).",
    hint: "Use a stack. Push open brackets, pop and match close brackets.",
    code: `<span class="kw">def</span> <span class="fn">isValid</span>(s):
    stack = []
    match = {<span class="st">')'</span>: <span class="st">'('</span>, <span class="st">'}'</span>: <span class="st">'{'</span>, <span class="st">']'</span>: <span class="st">'['</span>}
    <span class="kw">for</span> c <span class="kw">in</span> s:
        <span class="kw">if</span> c <span class="kw">in</span> match:
            <span class="kw">if</span> <span class="kw">not</span> stack <span class="kw">or</span> stack[-<span class="nm">1</span>] != match[c]:
                <span class="kw">return False</span>
            stack.pop()
        <span class="kw">else</span>: stack.append(c)
    <span class="kw">return not</span> stack`
  },
  {
    id: 18, lc: 125, title: "Valid Palindrome",
    topic: "Arrays", difficulty: "Easy",
    question: "A phrase is a palindrome if it reads the same forward and backward considering only alphanumeric characters and ignoring cases. Given a string s, return true if it is a palindrome.",
    hint: "Filter alphanumerics, lowercase, then compare with reverse.",
    code: `<span class="kw">def</span> <span class="fn">isPalindrome</span>(s):
    s = [c.lower() <span class="kw">for</span> c <span class="kw">in</span> s <span class="kw">if</span> c.isalnum()]
    <span class="kw">return</span> s == s[:<span class="nm">:-1</span>]`
  },
  {
    id: 19, lc: 56, title: "Merge Intervals",
    topic: "Arrays", difficulty: "Medium",
    question: "Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals and return an array of the non-overlapping intervals.",
    hint: "Sort by start. Merge if current start <= last end.",
    code: `<span class="kw">def</span> <span class="fn">merge</span>(intervals):
    intervals.sort()
    res = [intervals[<span class="nm">0</span>]]
    <span class="kw">for</span> s, e <span class="kw">in</span> intervals[<span class="nm">1</span>:]:
        <span class="kw">if</span> s <= res[-<span class="nm">1</span>][<span class="nm">1</span>]:
            res[-<span class="nm">1</span>][<span class="nm">1</span>] = <span class="fn">max</span>(res[-<span class="nm">1</span>][<span class="nm">1</span>], e)
        <span class="kw">else</span>: res.append([s, e])
    <span class="kw">return</span> res`
  },
  {
    id: 20, lc: 48, title: "Rotate Image",
    topic: "Arrays", difficulty: "Medium",
    question: "Given an n√ón 2D matrix representing an image, rotate the image by 90 degrees clockwise in-place.",
    hint: "Transpose the matrix, then reverse each row.",
    code: `<span class="kw">def</span> <span class="fn">rotate</span>(matrix):
    n = <span class="fn">len</span>(matrix)
    <span class="cm"># Transpose</span>
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(n):
        <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(i+<span class="nm">1</span>, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    <span class="cm"># Reverse rows</span>
    <span class="kw">for</span> row <span class="kw">in</span> matrix:
        row.reverse()`
  },
  {
    id: 21, lc: 54, title: "Spiral Matrix",
    topic: "Arrays", difficulty: "Medium",
    question: "Given an m√ón matrix, return all elements of the matrix in spiral order.",
    hint: "Peel outer layers. Shrink boundaries (top, bottom, left, right) inward.",
    code: `<span class="kw">def</span> <span class="fn">spiralOrder</span>(matrix):
    res = []
    t, b = <span class="nm">0</span>, <span class="fn">len</span>(matrix) - <span class="nm">1</span>
    l, r = <span class="nm">0</span>, <span class="fn">len</span>(matrix[<span class="nm">0</span>]) - <span class="nm">1</span>
    <span class="kw">while</span> t <= b <span class="kw">and</span> l <= r:
        <span class="kw">for</span> c <span class="kw">in</span> <span class="fn">range</span>(l, r+<span class="nm">1</span>): res.append(matrix[t][c])
        t += <span class="nm">1</span>
        <span class="kw">for</span> row <span class="kw">in</span> <span class="fn">range</span>(t, b+<span class="nm">1</span>): res.append(matrix[row][r])
        r -= <span class="nm">1</span>
        <span class="kw">if</span> t <= b:
            <span class="kw">for</span> c <span class="kw">in</span> <span class="fn">range</span>(r, l-<span class="nm">1</span>, -<span class="nm">1</span>): res.append(matrix[b][c])
            b -= <span class="nm">1</span>
        <span class="kw">if</span> l <= r:
            <span class="kw">for</span> row <span class="kw">in</span> <span class="fn">range</span>(b, t-<span class="nm">1</span>, -<span class="nm">1</span>): res.append(matrix[row][l])
            l += <span class="nm">1</span>
    <span class="kw">return</span> res`
  },
  {
    id: 22, lc: 73, title: "Set Matrix Zeroes",
    topic: "Arrays", difficulty: "Medium",
    question: "Given an m√ón integer matrix, if an element is 0, set its entire row and column to 0. Do it in-place.",
    hint: "Use first row and column as markers to avoid extra space.",
    code: `<span class="kw">def</span> <span class="fn">setZeroes</span>(matrix):
    rows, cols = <span class="fn">set</span>(), <span class="fn">set</span>()
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(matrix)):
        <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(matrix[<span class="nm">0</span>])):
            <span class="kw">if</span> matrix[i][j] == <span class="nm">0</span>:
                rows.add(i); cols.add(j)
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(matrix)):
        <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(matrix[<span class="nm">0</span>])):
            <span class="kw">if</span> i <span class="kw">in</span> rows <span class="kw">or</span> j <span class="kw">in</span> cols:
                matrix[i][j] = <span class="nm">0</span>`
  },
  {
    id: 23, lc: 79, title: "Word Search",
    topic: "Backtracking", difficulty: "Medium",
    question: "Given an m√ón grid of characters board and a string word, return true if word exists in the grid (cells can't be reused, must be adjacent horizontally/vertically).",
    hint: "DFS/backtracking from each cell. Mark visited, unmark on backtrack.",
    code: `<span class="kw">def</span> <span class="fn">exist</span>(board, word):
    m, n = <span class="fn">len</span>(board), <span class="fn">len</span>(board[<span class="nm">0</span>])
    <span class="kw">def</span> <span class="fn">dfs</span>(i, j, k):
        <span class="kw">if</span> k == <span class="fn">len</span>(word): <span class="kw">return True</span>
        <span class="kw">if not</span> (<span class="nm">0</span> <= i < m <span class="kw">and</span> <span class="nm">0</span> <= j < n) <span class="kw">or</span> board[i][j] != word[k]:
            <span class="kw">return False</span>
        tmp, board[i][j] = board[i][j], <span class="st">'#'</span>
        res = <span class="kw">any</span>(<span class="fn">dfs</span>(i+di,j+dj,k+<span class="nm">1</span>) <span class="kw">for</span> di,dj <span class="kw">in</span> [(<span class="nm">0</span>,<span class="nm">1</span>),(<span class="nm">0</span>,-<span class="nm">1</span>),(<span class="nm">1</span>,<span class="nm">0</span>),(-<span class="nm">1</span>,<span class="nm">0</span>)])
        board[i][j] = tmp
        <span class="kw">return</span> res
    <span class="kw">return any</span>(<span class="fn">dfs</span>(i,j,<span class="nm">0</span>) <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(m) <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(n))`
  },
  // ‚îÄ‚îÄ Binary Search ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  {
    id: 24, lc: 704, title: "Binary Search",
    topic: "Binary Search", difficulty: "Easy",
    question: "Given a sorted array of integers nums, and an integer target, write a function to search target in nums. If target exists, return its index. Otherwise return -1.",
    hint: "Classic binary search. Maintain l, r, compute mid = (l+r)//2.",
    code: `<span class="kw">def</span> <span class="fn">search</span>(nums, target):
    l, r = <span class="nm">0</span>, <span class="fn">len</span>(nums) - <span class="nm">1</span>
    <span class="kw">while</span> l <= r:
        m = (l + r) // <span class="nm">2</span>
        <span class="kw">if</span> nums[m] == target: <span class="kw">return</span> m
        <span class="kw">elif</span> nums[m] < target: l = m + <span class="nm">1</span>
        <span class="kw">else</span>: r = m - <span class="nm">1</span>
    <span class="kw">return</span> -<span class="nm">1</span>`
  },
  {
    id: 25, lc: 34, title: "Find First and Last Position in Sorted Array",
    topic: "Binary Search", difficulty: "Medium",
    question: "Given an array of integers sorted in ascending order, find the starting and ending position of a given target value. Return [-1, -1] if target is not found. Must be O(log n).",
    hint: "Two binary searches: one biased left, one biased right.",
    code: `<span class="kw">def</span> <span class="fn">searchRange</span>(nums, target):
    <span class="kw">def</span> <span class="fn">bs</span>(left):
        l, r, idx = <span class="nm">0</span>, <span class="fn">len</span>(nums)-<span class="nm">1</span>, -<span class="nm">1</span>
        <span class="kw">while</span> l <= r:
            m = (l + r) // <span class="nm">2</span>
            <span class="kw">if</span> nums[m] == target:
                idx = m
                <span class="kw">if</span> left: r = m - <span class="nm">1</span>
                <span class="kw">else</span>: l = m + <span class="nm">1</span>
            <span class="kw">elif</span> nums[m] < target: l = m + <span class="nm">1</span>
            <span class="kw">else</span>: r = m - <span class="nm">1</span>
        <span class="kw">return</span> idx
    <span class="kw">return</span> [<span class="fn">bs</span>(<span class="kw">True</span>), <span class="fn">bs</span>(<span class="kw">False</span>)]`
  },
  {
    id: 26, lc: 74, title: "Search a 2D Matrix",
    topic: "Binary Search", difficulty: "Medium",
    question: "Given an m√ón matrix where rows are sorted and the first integer of each row > last integer of previous row, write an efficient algorithm to search for a value target.",
    hint: "Treat as 1D array. mid maps to matrix[mid//n][mid%n].",
    code: `<span class="kw">def</span> <span class="fn">searchMatrix</span>(matrix, target):
    m, n = <span class="fn">len</span>(matrix), <span class="fn">len</span>(matrix[<span class="nm">0</span>])
    l, r = <span class="nm">0</span>, m * n - <span class="nm">1</span>
    <span class="kw">while</span> l <= r:
        mid = (l + r) // <span class="nm">2</span>
        val = matrix[mid // n][mid % n]
        <span class="kw">if</span> val == target: <span class="kw">return True</span>
        <span class="kw">elif</span> val < target: l = mid + <span class="nm">1</span>
        <span class="kw">else</span>: r = mid - <span class="nm">1</span>
    <span class="kw">return False</span>`
  },
  {
    id: 27, lc: 875, title: "Koko Eating Bananas",
    topic: "Binary Search", difficulty: "Medium",
    question: "Koko can eat k bananas per hour. She has h hours. Given piles of bananas, find the minimum integer k such that she can eat all the bananas within h hours.",
    hint: "Binary search on k. For each k, calculate total hours needed using ceil(pile/k).",
    code: `<span class="kw">import</span> math
<span class="kw">def</span> <span class="fn">minEatingSpeed</span>(piles, h):
    l, r = <span class="nm">1</span>, <span class="fn">max</span>(piles)
    <span class="kw">while</span> l < r:
        m = (l + r) // <span class="nm">2</span>
        hours = <span class="fn">sum</span>(math.ceil(p / m) <span class="kw">for</span> p <span class="kw">in</span> piles)
        <span class="kw">if</span> hours <= h: r = m
        <span class="kw">else</span>: l = m + <span class="nm">1</span>
    <span class="kw">return</span> l`
  },
  {
    id: 28, lc: 4, title: "Median of Two Sorted Arrays",
    topic: "Binary Search", difficulty: "Hard",
    question: "Given two sorted arrays nums1 and nums2 of size m and n, return the median of the two sorted arrays. The overall run time complexity should be O(log(m+n)).",
    hint: "Binary search on the smaller array. Partition both arrays such that left half = right half.",
    code: `<span class="kw">def</span> <span class="fn">findMedianSortedArrays</span>(A, B):
    <span class="kw">if</span> <span class="fn">len</span>(A) > <span class="fn">len</span>(B): A, B = B, A
    m, n = <span class="fn">len</span>(A), <span class="fn">len</span>(B)
    lo, hi = <span class="nm">0</span>, m
    <span class="kw">while</span> lo <= hi:
        i = (lo + hi) // <span class="nm">2</span>; j = (m + n + <span class="nm">1</span>) // <span class="nm">2</span> - i
        al = A[i-<span class="nm">1</span>] <span class="kw">if</span> i > <span class="nm">0</span> <span class="kw">else</span> -<span class="fn">float</span>(<span class="st">'inf'</span>)
        ar = A[i]   <span class="kw">if</span> i < m <span class="kw">else</span>  <span class="fn">float</span>(<span class="st">'inf'</span>)
        bl = B[j-<span class="nm">1</span>] <span class="kw">if</span> j > <span class="nm">0</span> <span class="kw">else</span> -<span class="fn">float</span>(<span class="st">'inf'</span>)
        br = B[j]   <span class="kw">if</span> j < n <span class="kw">else</span>  <span class="fn">float</span>(<span class="st">'inf'</span>)
        <span class="kw">if</span> al <= br <span class="kw">and</span> bl <= ar:
            <span class="kw">if</span> (m+n) % <span class="nm">2</span>: <span class="kw">return</span> <span class="fn">max</span>(al, bl)
            <span class="kw">return</span> (<span class="fn">max</span>(al,bl) + <span class="fn">min</span>(ar,br)) / <span class="nm">2</span>
        <span class="kw">elif</span> al > br: hi = i - <span class="nm">1</span>
        <span class="kw">else</span>: lo = i + <span class="nm">1</span>`
  },
  {
    id: 29, lc: 981, title: "Time Based Key-Value Store",
    topic: "Binary Search", difficulty: "Medium",
    question: "Design a time-based key-value data structure that can store multiple values for the same key at different timestamps. Implement set(key, value, timestamp) and get(key, timestamp) which returns the value with the largest timestamp <= given timestamp.",
    hint: "Store list of (timestamp, value). Binary search on get.",
    code: `<span class="kw">from</span> collections <span class="kw">import</span> defaultdict
<span class="kw">import</span> bisect
<span class="kw">class</span> <span class="fn">TimeMap</span>:
    <span class="kw">def</span> <span class="fn">__init__</span>(self):
        self.d = defaultdict(<span class="fn">list</span>)
    <span class="kw">def</span> <span class="fn">set</span>(self, key, val, ts):
        self.d[key].append((ts, val))
    <span class="kw">def</span> <span class="fn">get</span>(self, key, ts):
        pairs = self.d[key]
        i = bisect.bisect_right(pairs, (ts, <span class="fn">chr</span>(<span class="nm">127</span>)))
        <span class="kw">return</span> pairs[i-<span class="nm">1</span>][<span class="nm">1</span>] <span class="kw">if</span> i > <span class="nm">0</span> <span class="kw">else</span> <span class="st">""</span>`
  },
  // ‚îÄ‚îÄ Linked Lists ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  {
    id: 30, lc: 206, title: "Reverse a Linked List",
    topic: "Linked Lists", difficulty: "Easy",
    question: "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    hint: "Iterative: use prev=None, cur=head. Reassign next pointers in-place.",
    code: `<span class="kw">def</span> <span class="fn">reverseList</span>(head):
    prev = <span class="kw">None</span>
    cur = head
    <span class="kw">while</span> cur:
        nxt = cur.next
        cur.next = prev
        prev = cur
        cur = nxt
    <span class="kw">return</span> prev`
  },
  {
    id: 31, lc: 141, title: "Detect Cycle in Linked List",
    topic: "Linked Lists", difficulty: "Easy",
    question: "Given head of a linked list, determine if the linked list has a cycle in it.",
    hint: "Floyd's cycle detection: slow/fast pointers. If they meet, cycle exists.",
    code: `<span class="kw">def</span> <span class="fn">hasCycle</span>(head):
    slow = fast = head
    <span class="kw">while</span> fast <span class="kw">and</span> fast.next:
        slow = slow.next
        fast = fast.next.next
        <span class="kw">if</span> slow == fast: <span class="kw">return True</span>
    <span class="kw">return False</span>`
  },
  {
    id: 32, lc: 21, title: "Merge Two Sorted Lists",
    topic: "Linked Lists", difficulty: "Easy",
    question: "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in sorted order and return the merged list head.",
    hint: "Use a dummy head. Iteratively attach the smaller node.",
    code: `<span class="kw">def</span> <span class="fn">mergeTwoLists</span>(l1, l2):
    dummy = cur = ListNode(<span class="nm">0</span>)
    <span class="kw">while</span> l1 <span class="kw">and</span> l2:
        <span class="kw">if</span> l1.val <= l2.val:
            cur.next = l1; l1 = l1.next
        <span class="kw">else</span>:
            cur.next = l2; l2 = l2.next
        cur = cur.next
    cur.next = l1 <span class="kw">or</span> l2
    <span class="kw">return</span> dummy.next`
  },
  {
    id: 33, lc: 23, title: "Merge K Sorted Lists",
    topic: "Linked Lists", difficulty: "Hard",
    question: "You are given an array of k linked-lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
    hint: "Use a min-heap of (val, idx, node). Pop smallest, push its next.",
    code: `<span class="kw">import</span> heapq
<span class="kw">def</span> <span class="fn">mergeKLists</span>(lists):
    heap = []
    <span class="kw">for</span> i, node <span class="kw">in</span> <span class="fn">enumerate</span>(lists):
        <span class="kw">if</span> node: heapq.heappush(heap, (node.val, i, node))
    dummy = cur = ListNode(<span class="nm">0</span>)
    <span class="kw">while</span> heap:
        val, i, node = heapq.heappop(heap)
        cur.next = node; cur = cur.next
        <span class="kw">if</span> node.next: heapq.heappush(heap, (node.next.val, i, node.next))
    <span class="kw">return</span> dummy.next`
  },
  {
    id: 34, lc: 19, title: "Remove Nth Node From End of List",
    topic: "Linked Lists", difficulty: "Medium",
    question: "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
    hint: "Two pointers: advance fast n steps, then move both until fast.next is None.",
    code: `<span class="kw">def</span> <span class="fn">removeNthFromEnd</span>(head, n):
    dummy = ListNode(<span class="nm">0</span>, head)
    slow = fast = dummy
    <span class="kw">for</span> _ <span class="kw">in</span> <span class="fn">range</span>(n + <span class="nm">1</span>): fast = fast.next
    <span class="kw">while</span> fast:
        slow = slow.next; fast = fast.next
    slow.next = slow.next.next
    <span class="kw">return</span> dummy.next`
  },
  {
    id: 35, lc: 143, title: "Reorder List",
    topic: "Linked Lists", difficulty: "Medium",
    question: "Given list L0‚ÜíL1‚Üí‚Ä¶‚ÜíLn-1‚ÜíLn, reorder it to L0‚ÜíLn‚ÜíL1‚ÜíLn-1‚ÜíL2‚ÜíLn-2‚Üí‚Ä¶ Do not modify node values, only nodes.",
    hint: "Find middle, reverse second half, then merge two halves alternating.",
    code: `<span class="kw">def</span> <span class="fn">reorderList</span>(head):
    slow = fast = head
    <span class="kw">while</span> fast <span class="kw">and</span> fast.next:
        slow = slow.next; fast = fast.next.next
    prev, cur = <span class="kw">None</span>, slow.next; slow.next = <span class="kw">None</span>
    <span class="kw">while</span> cur:
        nxt = cur.next; cur.next = prev; prev = cur; cur = nxt
    l1, l2 = head, prev
    <span class="kw">while</span> l2:
        l1n, l2n = l1.next, l2.next
        l1.next = l2; l2.next = l1n
        l1, l2 = l1n, l2n`
  },
  {
    id: 36, lc: 146, title: "LRU Cache",
    topic: "Linked Lists", difficulty: "Medium",
    question: "Design a data structure that follows the Least Recently Used (LRU) cache constraints. Implement get(key) and put(key, value), both in O(1) average.",
    hint: "Doubly linked list + hashmap. Move to front on access, evict from tail.",
    code: `<span class="kw">from</span> collections <span class="kw">import</span> OrderedDict
<span class="kw">class</span> <span class="fn">LRUCache</span>:
    <span class="kw">def</span> <span class="fn">__init__</span>(self, cap):
        self.cap = cap
        self.cache = OrderedDict()
    <span class="kw">def</span> <span class="fn">get</span>(self, key):
        <span class="kw">if</span> key <span class="kw">not in</span> self.cache: <span class="kw">return</span> -<span class="nm">1</span>
        self.cache.move_to_end(key)
        <span class="kw">return</span> self.cache[key]
    <span class="kw">def</span> <span class="fn">put</span>(self, key, val):
        self.cache[key] = val
        self.cache.move_to_end(key)
        <span class="kw">if</span> <span class="fn">len</span>(self.cache) > self.cap:
            self.cache.popitem(last=<span class="kw">False</span>)`
  },
  {
    id: 37, lc: 138, title: "Copy List with Random Pointer",
    topic: "Linked Lists", difficulty: "Medium",
    question: "A linked list of length n is given where each node has an extra random pointer (can point to any node or null). Construct a deep copy of the list.",
    hint: "Two passes: first map old‚Üínew nodes, then assign next/random pointers.",
    code: `<span class="kw">def</span> <span class="fn">copyRandomList</span>(head):
    old_to_new = {<span class="kw">None</span>: <span class="kw">None</span>}
    cur = head
    <span class="kw">while</span> cur:
        old_to_new[cur] = Node(cur.val)
        cur = cur.next
    cur = head
    <span class="kw">while</span> cur:
        old_to_new[cur].next = old_to_new[cur.next]
        old_to_new[cur].random = old_to_new[cur.random]
        cur = cur.next
    <span class="kw">return</span> old_to_new[head]`
  },
  {
    id: 38, lc: 287, title: "Find the Duplicate Number",
    topic: "Linked Lists", difficulty: "Medium",
    question: "Given an array nums containing n+1 integers where each is in range [1, n], there is only one repeated number. Find that repeated number without modifying the array using O(1) extra space.",
    hint: "Floyd's cycle detection treating array as a linked list. Index = next node.",
    code: `<span class="kw">def</span> <span class="fn">findDuplicate</span>(nums):
    slow = fast = nums[<span class="nm">0</span>]
    <span class="kw">while True</span>:
        slow = nums[slow]
        fast = nums[nums[fast]]
        <span class="kw">if</span> slow == fast: <span class="kw">break</span>
    slow = nums[<span class="nm">0</span>]
    <span class="kw">while</span> slow != fast:
        slow = nums[slow]
        fast = nums[fast]
    <span class="kw">return</span> slow`
  },
  {
    id: 39, lc: 2, title: "Add Two Numbers",
    topic: "Linked Lists", difficulty: "Medium",
    question: "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order. Add the two numbers and return the sum as a linked list.",
    hint: "Simulate addition with carry. Process both lists digit by digit.",
    code: `<span class="kw">def</span> <span class="fn">addTwoNumbers</span>(l1, l2):
    dummy = cur = ListNode(<span class="nm">0</span>)
    carry = <span class="nm">0</span>
    <span class="kw">while</span> l1 <span class="kw">or</span> l2 <span class="kw">or</span> carry:
        v1 = l1.val <span class="kw">if</span> l1 <span class="kw">else</span> <span class="nm">0</span>
        v2 = l2.val <span class="kw">if</span> l2 <span class="kw">else</span> <span class="nm">0</span>
        s = v1 + v2 + carry
        carry, val = divmod(s, <span class="nm">10</span>)
        cur.next = ListNode(val); cur = cur.next
        l1 = l1.next <span class="kw">if</span> l1 <span class="kw">else None</span>
        l2 = l2.next <span class="kw">if</span> l2 <span class="kw">else None</span>
    <span class="kw">return</span> dummy.next`
  },
  // ‚îÄ‚îÄ Trees ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  {
    id: 40, lc: 226, title: "Invert Binary Tree",
    topic: "Trees", difficulty: "Easy",
    question: "Given the root of a binary tree, invert the tree, and return its root.",
    hint: "Recursively swap left and right children at every node.",
    code: `<span class="kw">def</span> <span class="fn">invertTree</span>(root):
    <span class="kw">if not</span> root: <span class="kw">return None</span>
    root.left, root.right = (
        <span class="fn">invertTree</span>(root.right),
        <span class="fn">invertTree</span>(root.left))
    <span class="kw">return</span> root`
  },
  {
    id: 41, lc: 104, title: "Maximum Depth of Binary Tree",
    topic: "Trees", difficulty: "Easy",
    question: "Given the root of a binary tree, return its maximum depth (number of nodes along the longest path from root to the farthest leaf).",
    hint: "Recursive DFS: return 1 + max(left_depth, right_depth).",
    code: `<span class="kw">def</span> <span class="fn">maxDepth</span>(root):
    <span class="kw">if not</span> root: <span class="kw">return</span> <span class="nm">0</span>
    <span class="kw">return</span> <span class="nm">1</span> + <span class="fn">max</span>(<span class="fn">maxDepth</span>(root.left),
                       <span class="fn">maxDepth</span>(root.right))`
  },
  {
    id: 42, lc: 100, title: "Same Tree",
    topic: "Trees", difficulty: "Easy",
    question: "Given the roots of two binary trees p and q, write a function to check if they are the same or not (structurally identical with same node values).",
    hint: "Recursively check: both None, or values equal and both subtrees same.",
    code: `<span class="kw">def</span> <span class="fn">isSameTree</span>(p, q):
    <span class="kw">if not</span> p <span class="kw">and not</span> q: <span class="kw">return True</span>
    <span class="kw">if not</span> p <span class="kw">or not</span> q: <span class="kw">return False</span>
    <span class="kw">return</span> (p.val == q.val <span class="kw">and</span>
            <span class="fn">isSameTree</span>(p.left, q.left) <span class="kw">and</span>
            <span class="fn">isSameTree</span>(p.right, q.right))`
  },
  {
    id: 43, lc: 572, title: "Subtree of Another Tree",
    topic: "Trees", difficulty: "Easy",
    question: "Given roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and values as subRoot.",
    hint: "For each node in root, check if isSameTree(node, subRoot).",
    code: `<span class="kw">def</span> <span class="fn">isSubtree</span>(root, sub):
    <span class="kw">if not</span> root: <span class="kw">return False</span>
    <span class="kw">if</span> <span class="fn">isSameTree</span>(root, sub): <span class="kw">return True</span>
    <span class="kw">return</span> (<span class="fn">isSubtree</span>(root.left, sub) <span class="kw">or</span>
            <span class="fn">isSubtree</span>(root.right, sub))
<span class="kw">def</span> <span class="fn">isSameTree</span>(p, q):
    <span class="kw">if not</span> p <span class="kw">and not</span> q: <span class="kw">return True</span>
    <span class="kw">if not</span> p <span class="kw">or not</span> q: <span class="kw">return False</span>
    <span class="kw">return</span> p.val==q.val <span class="kw">and</span> <span class="fn">isSameTree</span>(p.left,q.left) <span class="kw">and</span> <span class="fn">isSameTree</span>(p.right,q.right)`
  },
  {
    id: 44, lc: 235, title: "Lowest Common Ancestor of a BST",
    topic: "Trees", difficulty: "Medium",
    question: "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes p and q.",
    hint: "If both p,q > root go right; if both < root go left; else root is LCA.",
    code: `<span class="kw">def</span> <span class="fn">lowestCommonAncestor</span>(root, p, q):
    <span class="kw">while</span> root:
        <span class="kw">if</span> p.val > root.val <span class="kw">and</span> q.val > root.val:
            root = root.right
        <span class="kw">elif</span> p.val < root.val <span class="kw">and</span> q.val < root.val:
            root = root.left
        <span class="kw">else</span>: <span class="kw">return</span> root`
  },
  {
    id: 45, lc: 102, title: "Binary Tree Level Order Traversal",
    topic: "Trees", difficulty: "Medium",
    question: "Given the root of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).",
    hint: "BFS with a queue. Process all nodes at each level before moving on.",
    code: `<span class="kw">from</span> collections <span class="kw">import</span> deque
<span class="kw">def</span> <span class="fn">levelOrder</span>(root):
    <span class="kw">if not</span> root: <span class="kw">return</span> []
    q, res = deque([root]), []
    <span class="kw">while</span> q:
        level = []
        <span class="kw">for</span> _ <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(q)):
            node = q.popleft()
            level.append(node.val)
            <span class="kw">if</span> node.left: q.append(node.left)
            <span class="kw">if</span> node.right: q.append(node.right)
        res.append(level)
    <span class="kw">return</span> res`
  },
  {
    id: 46, lc: 98, title: "Validate Binary Search Tree",
    topic: "Trees", difficulty: "Medium",
    question: "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST has left < root < right for every node considering the full subtree bounds.",
    hint: "Pass min/max bounds recursively. Left subtree max = root.val, right subtree min = root.val.",
    code: `<span class="kw">def</span> <span class="fn">isValidBST</span>(root):
    <span class="kw">def</span> <span class="fn">valid</span>(node, lo, hi):
        <span class="kw">if not</span> node: <span class="kw">return True</span>
        <span class="kw">if not</span> (lo < node.val < hi): <span class="kw">return False</span>
        <span class="kw">return</span> (<span class="fn">valid</span>(node.left, lo, node.val) <span class="kw">and</span>
                <span class="fn">valid</span>(node.right, node.val, hi))
    <span class="kw">return</span> <span class="fn">valid</span>(root, -<span class="fn">float</span>(<span class="st">'inf'</span>), <span class="fn">float</span>(<span class="st">'inf'</span>))`
  },
  {
    id: 47, lc: 230, title: "Kth Smallest Element in a BST",
    topic: "Trees", difficulty: "Medium",
    question: "Given the root of a BST and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.",
    hint: "In-order traversal of BST gives sorted order. Return kth element.",
    code: `<span class="kw">def</span> <span class="fn">kthSmallest</span>(root, k):
    stack, cur = [], root
    n = <span class="nm">0</span>
    <span class="kw">while</span> stack <span class="kw">or</span> cur:
        <span class="kw">while</span> cur: stack.append(cur); cur = cur.left
        cur = stack.pop(); n += <span class="nm">1</span>
        <span class="kw">if</span> n == k: <span class="kw">return</span> cur.val
        cur = cur.right`
  },
  {
    id: 48, lc: 105, title: "Construct Tree from Preorder and Inorder",
    topic: "Trees", difficulty: "Medium",
    question: "Given two integer arrays preorder and inorder where preorder is the preorder traversal and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
    hint: "preorder[0] is root. Find its position in inorder to split left/right subtrees.",
    code: `<span class="kw">def</span> <span class="fn">buildTree</span>(preorder, inorder):
    <span class="kw">if not</span> preorder: <span class="kw">return None</span>
    root = TreeNode(preorder[<span class="nm">0</span>])
    mid = inorder.index(preorder[<span class="nm">0</span>])
    root.left = <span class="fn">buildTree</span>(preorder[<span class="nm">1</span>:mid+<span class="nm">1</span>], inorder[:mid])
    root.right = <span class="fn">buildTree</span>(preorder[mid+<span class="nm">1</span>:], inorder[mid+<span class="nm">1</span>:])
    <span class="kw">return</span> root`
  },
  {
    id: 49, lc: 124, title: "Binary Tree Maximum Path Sum",
    topic: "Trees", difficulty: "Hard",
    question: "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes has an edge. A node can only appear once. The path does not need to pass through the root. Given root, return the maximum path sum.",
    hint: "DFS. At each node, max contribution = node.val + max(0, left_gain, right_gain). Track global max = node.val + left_gain + right_gain.",
    code: `<span class="kw">def</span> <span class="fn">maxPathSum</span>(root):
    res = [root.val]
    <span class="kw">def</span> <span class="fn">dfs</span>(node):
        <span class="kw">if not</span> node: <span class="kw">return</span> <span class="nm">0</span>
        l = <span class="fn">max</span>(<span class="fn">dfs</span>(node.left), <span class="nm">0</span>)
        r = <span class="fn">max</span>(<span class="fn">dfs</span>(node.right), <span class="nm">0</span>)
        res[<span class="nm">0</span>] = <span class="fn">max</span>(res[<span class="nm">0</span>], node.val + l + r)
        <span class="kw">return</span> node.val + <span class="fn">max</span>(l, r)
    <span class="fn">dfs</span>(root)
    <span class="kw">return</span> res[<span class="nm">0</span>]`
  },
  {
    id: 50, lc: 297, title: "Serialize and Deserialize Binary Tree",
    topic: "Trees", difficulty: "Hard",
    question: "Design an algorithm to serialize and deserialize a binary tree. Serialization is converting a tree to a string, deserialization is the reverse. Your implementation must be valid inverse functions.",
    hint: "BFS/preorder with 'N' for null. Reconstruct using a queue/index.",
    code: `<span class="kw">class</span> <span class="fn">Codec</span>:
    <span class="kw">def</span> <span class="fn">serialize</span>(self, root):
        res = []
        <span class="kw">def</span> <span class="fn">dfs</span>(n):
            <span class="kw">if not</span> n: res.append(<span class="st">"N"</span>); <span class="kw">return</span>
            res.append(<span class="fn">str</span>(n.val)); <span class="fn">dfs</span>(n.left); <span class="fn">dfs</span>(n.right)
        <span class="fn">dfs</span>(root); <span class="kw">return</span> <span class="st">","</span>.join(res)
    <span class="kw">def</span> <span class="fn">deserialize</span>(self, data):
        vals = iter(data.split(<span class="st">","</span>))
        <span class="kw">def</span> <span class="fn">dfs</span>():
            v = <span class="fn">next</span>(vals)
            <span class="kw">if</span> v == <span class="st">"N"</span>: <span class="kw">return None</span>
            node = TreeNode(<span class="fn">int</span>(v))
            node.left, node.right = <span class="fn">dfs</span>(), <span class="fn">dfs</span>()
            <span class="kw">return</span> node
        <span class="kw">return</span> <span class="fn">dfs</span>()`
  },
  {
    id: 51, lc: 543, title: "Diameter of Binary Tree",
    topic: "Trees", difficulty: "Easy",
    question: "Given the root of a binary tree, return the length of the diameter of the tree. The diameter is the length of the longest path between any two nodes (may or may not pass through root).",
    hint: "DFS. Diameter at each node = left_depth + right_depth. Track global max.",
    code: `<span class="kw">def</span> <span class="fn">diameterOfBinaryTree</span>(root):
    res = [<span class="nm">0</span>]
    <span class="kw">def</span> <span class="fn">dfs</span>(node):
        <span class="kw">if not</span> node: <span class="kw">return</span> -<span class="nm">1</span>
        l, r = <span class="fn">dfs</span>(node.left), <span class="fn">dfs</span>(node.right)
        res[<span class="nm">0</span>] = <span class="fn">max</span>(res[<span class="nm">0</span>], l + r + <span class="nm">2</span>)
        <span class="kw">return</span> <span class="nm">1</span> + <span class="fn">max</span>(l, r)
    <span class="fn">dfs</span>(root)
    <span class="kw">return</span> res[<span class="nm">0</span>]`
  },
  {
    id: 52, lc: 1448, title: "Count Good Nodes in Binary Tree",
    topic: "Trees", difficulty: "Medium",
    question: "Given a binary tree root, a node X is a 'good' node if no node with a greater value is on the path from root to X. Return the number of good nodes.",
    hint: "DFS, pass current max. Node is good if node.val >= max seen so far.",
    code: `<span class="kw">def</span> <span class="fn">goodNodes</span>(root):
    <span class="kw">def</span> <span class="fn">dfs</span>(node, mx):
        <span class="kw">if not</span> node: <span class="kw">return</span> <span class="nm">0</span>
        good = <span class="nm">1</span> <span class="kw">if</span> node.val >= mx <span class="kw">else</span> <span class="nm">0</span>
        mx = <span class="fn">max</span>(mx, node.val)
        <span class="kw">return</span> good + <span class="fn">dfs</span>(node.left, mx) + <span class="fn">dfs</span>(node.right, mx)
    <span class="kw">return</span> <span class="fn">dfs</span>(root, root.val)`
  },
  // ‚îÄ‚îÄ Graphs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  {
    id: 53, lc: 200, title: "Number of Islands",
    topic: "Graphs", difficulty: "Medium",
    question: "Given an m√ón 2D binary grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and formed by connecting adjacent land horizontally/vertically.",
    hint: "BFS/DFS from each unvisited '1'. Mark cells as visited by setting to '0'.",
    code: `<span class="kw">def</span> <span class="fn">numIslands</span>(grid):
    count = <span class="nm">0</span>
    <span class="kw">def</span> <span class="fn">dfs</span>(i, j):
        <span class="kw">if</span> i < <span class="nm">0</span> <span class="kw">or</span> i >= <span class="fn">len</span>(grid) <span class="kw">or</span> j < <span class="nm">0</span> <span class="kw">or</span> \
           j >= <span class="fn">len</span>(grid[<span class="nm">0</span>]) <span class="kw">or</span> grid[i][j] != <span class="st">'1'</span>: <span class="kw">return</span>
        grid[i][j] = <span class="st">'0'</span>
        <span class="kw">for</span> di, dj <span class="kw">in</span> [(<span class="nm">1</span>,<span class="nm">0</span>),(-<span class="nm">1</span>,<span class="nm">0</span>),(<span class="nm">0</span>,<span class="nm">1</span>),(<span class="nm">0</span>,-<span class="nm">1</span>)]:
            <span class="fn">dfs</span>(i+di, j+dj)
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(grid)):
        <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(grid[<span class="nm">0</span>])):
            <span class="kw">if</span> grid[i][j] == <span class="st">'1'</span>: <span class="fn">dfs</span>(i,j); count += <span class="nm">1</span>
    <span class="kw">return</span> count`
  },
  {
    id: 54, lc: 133, title: "Clone Graph",
    topic: "Graphs", difficulty: "Medium",
    question: "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node has a val and a list of neighbors.",
    hint: "BFS/DFS with a visited hashmap {original: clone}.",
    code: `<span class="kw">def</span> <span class="fn">cloneGraph</span>(node):
    clones = {}
    <span class="kw">def</span> <span class="fn">dfs</span>(n):
        <span class="kw">if</span> n <span class="kw">in</span> clones: <span class="kw">return</span> clones[n]
        clone = Node(n.val)
        clones[n] = clone
        <span class="kw">for</span> nb <span class="kw">in</span> n.neighbors:
            clone.neighbors.append(<span class="fn">dfs</span>(nb))
        <span class="kw">return</span> clone
    <span class="kw">return</span> <span class="fn">dfs</span>(node) <span class="kw">if</span> node <span class="kw">else None</span>`
  },
  {
    id: 55, lc: 417, title: "Pacific Atlantic Water Flow",
    topic: "Graphs", difficulty: "Medium",
    question: "Rain water can flow to an adjacent cell if it has equal or lower height. Return cells from which water can flow to both Pacific (top/left) and Atlantic (bottom/right) oceans.",
    hint: "Reverse BFS from both oceans simultaneously. A cell is valid if in both sets.",
    code: `<span class="kw">from</span> collections <span class="kw">import</span> deque
<span class="kw">def</span> <span class="fn">pacificAtlantic</span>(heights):
    m, n = <span class="fn">len</span>(heights), <span class="fn">len</span>(heights[<span class="nm">0</span>])
    <span class="kw">def</span> <span class="fn">bfs</span>(starts):
        vis = <span class="fn">set</span>(starts); q = deque(starts)
        <span class="kw">while</span> q:
            r, c = q.popleft()
            <span class="kw">for</span> dr, dc <span class="kw">in</span> [(<span class="nm">1</span>,<span class="nm">0</span>),(-<span class="nm">1</span>,<span class="nm">0</span>),(<span class="nm">0</span>,<span class="nm">1</span>),(<span class="nm">0</span>,-<span class="nm">1</span>)]:
                nr, nc = r+dr, c+dc
                <span class="kw">if</span> <span class="nm">0</span><=nr<m <span class="kw">and</span> <span class="nm">0</span><=nc<n <span class="kw">and</span> (nr,nc) <span class="kw">not in</span> vis <span class="kw">and</span> heights[nr][nc]>=heights[r][c]:
                    vis.add((nr,nc)); q.append((nr,nc))
        <span class="kw">return</span> vis
    pac = <span class="fn">bfs</span>([(i,<span class="nm">0</span>) <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(m)] + [(<span class="nm">0</span>,j) <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(n)])
    atl = <span class="fn">bfs</span>([(i,n-<span class="nm">1</span>) <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(m)] + [(m-<span class="nm">1</span>,j) <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(n)])
    <span class="kw">return</span> [[r,c] <span class="kw">for</span> r,c <span class="kw">in</span> pac <span class="kw">if</span> (r,c) <span class="kw">in</span> atl]`
  },
  {
    id: 56, lc: 207, title: "Course Schedule",
    topic: "Graphs", difficulty: "Medium",
    question: "There are numCourses courses labeled 0 to n-1. You're given prerequisites pairs [a, b] meaning you must take b before a. Return true if you can finish all courses.",
    hint: "Cycle detection in directed graph via DFS with 3 states: unvisited, visiting, visited.",
    code: `<span class="kw">def</span> <span class="fn">canFinish</span>(n, prereqs):
    adj = [[] <span class="kw">for</span> _ <span class="kw">in</span> <span class="fn">range</span>(n)]
    <span class="kw">for</span> a, b <span class="kw">in</span> prereqs: adj[a].append(b)
    visited = [<span class="nm">0</span>] * n  <span class="cm"># 0=unvis,1=visiting,2=done</span>
    <span class="kw">def</span> <span class="fn">dfs</span>(c):
        <span class="kw">if</span> visited[c] == <span class="nm">1</span>: <span class="kw">return False</span>
        <span class="kw">if</span> visited[c] == <span class="nm">2</span>: <span class="kw">return True</span>
        visited[c] = <span class="nm">1</span>
        <span class="kw">for</span> pre <span class="kw">in</span> adj[c]:
            <span class="kw">if not</span> <span class="fn">dfs</span>(pre): <span class="kw">return False</span>
        visited[c] = <span class="nm">2</span>; <span class="kw">return True</span>
    <span class="kw">return all</span>(<span class="fn">dfs</span>(c) <span class="kw">for</span> c <span class="kw">in</span> <span class="fn">range</span>(n))`
  },
  {
    id: 57, lc: 210, title: "Course Schedule II",
    topic: "Graphs", difficulty: "Medium",
    question: "Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them. If impossible, return an empty array.",
    hint: "Topological sort via DFS. Append to result after processing all neighbors (post-order).",
    code: `<span class="kw">def</span> <span class="fn">findOrder</span>(n, prereqs):
    adj = [[] <span class="kw">for</span> _ <span class="kw">in</span> <span class="fn">range</span>(n)]
    <span class="kw">for</span> a, b <span class="kw">in</span> prereqs: adj[a].append(b)
    visit, order = [<span class="nm">0</span>] * n, []
    <span class="kw">def</span> <span class="fn">dfs</span>(c):
        <span class="kw">if</span> visit[c] == <span class="nm">1</span>: <span class="kw">return False</span>
        <span class="kw">if</span> visit[c] == <span class="nm">2</span>: <span class="kw">return True</span>
        visit[c] = <span class="nm">1</span>
        <span class="kw">for</span> pre <span class="kw">in</span> adj[c]:
            <span class="kw">if not</span> <span class="fn">dfs</span>(pre): <span class="kw">return False</span>
        visit[c] = <span class="nm">2</span>; order.append(c); <span class="kw">return True</span>
    <span class="kw">for</span> c <span class="kw">in</span> <span class="fn">range</span>(n):
        <span class="kw">if not</span> <span class="fn">dfs</span>(c): <span class="kw">return</span> []
    <span class="kw">return</span> order`
  },
  {
    id: 58, lc: 994, title: "Rotting Oranges",
    topic: "Graphs", difficulty: "Medium",
    question: "In a grid, 0=empty, 1=fresh orange, 2=rotten orange. Every minute, rotten oranges infect adjacent fresh oranges. Return minimum minutes until no fresh orange remains, or -1 if impossible.",
    hint: "Multi-source BFS from all rotten oranges simultaneously. Track fresh count.",
    code: `<span class="kw">from</span> collections <span class="kw">import</span> deque
<span class="kw">def</span> <span class="fn">orangesRotting</span>(grid):
    m, n = <span class="fn">len</span>(grid), <span class="fn">len</span>(grid[<span class="nm">0</span>])
    q, fresh = deque(), <span class="nm">0</span>
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(m):
        <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(n):
            <span class="kw">if</span> grid[i][j] == <span class="nm">2</span>: q.append((i,j,<span class="nm">0</span>))
            <span class="kw">elif</span> grid[i][j] == <span class="nm">1</span>: fresh += <span class="nm">1</span>
    mins = <span class="nm">0</span>
    <span class="kw">while</span> q:
        r, c, t = q.popleft()
        <span class="kw">for</span> dr, dc <span class="kw">in</span> [(<span class="nm">1</span>,<span class="nm">0</span>),(-<span class="nm">1</span>,<span class="nm">0</span>),(<span class="nm">0</span>,<span class="nm">1</span>),(<span class="nm">0</span>,-<span class="nm">1</span>)]:
            nr, nc = r+dr, c+dc
            <span class="kw">if</span> <span class="nm">0</span><=nr<m <span class="kw">and</span> <span class="nm">0</span><=nc<n <span class="kw">and</span> grid[nr][nc] == <span class="nm">1</span>:
                grid[nr][nc] = <span class="nm">2</span>; fresh -= <span class="nm">1</span>
                mins = t + <span class="nm">1</span>; q.append((nr,nc,t+<span class="nm">1</span>))
    <span class="kw">return</span> mins <span class="kw">if</span> fresh == <span class="nm">0</span> <span class="kw">else</span> -<span class="nm">1</span>`
  },
  {
    id: 59, lc: 1091, title: "Shortest Path in Binary Matrix",
    topic: "Graphs", difficulty: "Medium",
    question: "Given an n√ón binary matrix grid, return the length of the shortest clear path from top-left to bottom-right. A clear path has all 0s and goes 8-directionally. Return -1 if no such path.",
    hint: "BFS from (0,0). Level = path length. Check all 8 directions.",
    code: `<span class="kw">from</span> collections <span class="kw">import</span> deque
<span class="kw">def</span> <span class="fn">shortestPathBinaryMatrix</span>(grid):
    n = <span class="fn">len</span>(grid)
    <span class="kw">if</span> grid[<span class="nm">0</span>][<span class="nm">0</span>] <span class="kw">or</span> grid[n-<span class="nm">1</span>][n-<span class="nm">1</span>]: <span class="kw">return</span> -<span class="nm">1</span>
    q = deque([(<span class="nm">0</span>, <span class="nm">0</span>, <span class="nm">1</span>)]); grid[<span class="nm">0</span>][<span class="nm">0</span>] = <span class="nm">1</span>
    dirs = [(-<span class="nm">1</span>,-<span class="nm">1</span>),(-<span class="nm">1</span>,<span class="nm">0</span>),(-<span class="nm">1</span>,<span class="nm">1</span>),(<span class="nm">0</span>,-<span class="nm">1</span>),(<span class="nm">0</span>,<span class="nm">1</span>),(<span class="nm">1</span>,-<span class="nm">1</span>),(<span class="nm">1</span>,<span class="nm">0</span>),(<span class="nm">1</span>,<span class="nm">1</span>)]
    <span class="kw">while</span> q:
        r, c, d = q.popleft()
        <span class="kw">if</span> r == n-<span class="nm">1</span> <span class="kw">and</span> c == n-<span class="nm">1</span>: <span class="kw">return</span> d
        <span class="kw">for</span> dr, dc <span class="kw">in</span> dirs:
            nr, nc = r+dr, c+dc
            <span class="kw">if</span> <span class="nm">0</span><=nr<n <span class="kw">and</span> <span class="nm">0</span><=nc<n <span class="kw">and not</span> grid[nr][nc]:
                grid[nr][nc] = <span class="nm">1</span>; q.append((nr,nc,d+<span class="nm">1</span>))
    <span class="kw">return</span> -<span class="nm">1</span>`
  },
  {
    id: 60, lc: 127, title: "Word Ladder",
    topic: "Graphs", difficulty: "Hard",
    question: "Given two words beginWord and endWord, and a word list, return the number of words in the shortest transformation sequence from beginWord to endWord (change one letter at a time, each intermediate word must be in wordList).",
    hint: "BFS. For each word, try all 26 letter swaps. Use a set for O(1) lookup.",
    code: `<span class="kw">from</span> collections <span class="kw">import</span> deque
<span class="kw">def</span> <span class="fn">ladderLength</span>(begin, end, wordList):
    ws = <span class="fn">set</span>(wordList)
    <span class="kw">if</span> end <span class="kw">not in</span> ws: <span class="kw">return</span> <span class="nm">0</span>
    q = deque([(begin, <span class="nm">1</span>)])
    <span class="kw">while</span> q:
        word, steps = q.popleft()
        <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(word)):
            <span class="kw">for</span> c <span class="kw">in</span> <span class="st">'abcdefghijklmnopqrstuvwxyz'</span>:
                nw = word[:i] + c + word[i+<span class="nm">1</span>:]
                <span class="kw">if</span> nw == end: <span class="kw">return</span> steps + <span class="nm">1</span>
                <span class="kw">if</span> nw <span class="kw">in</span> ws:
                    ws.discard(nw); q.append((nw, steps+<span class="nm">1</span>))
    <span class="kw">return</span> <span class="nm">0</span>`
  },
  // ‚îÄ‚îÄ Dynamic Programming ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  {
    id: 61, lc: 70, title: "Climbing Stairs",
    topic: "Dynamic Programming", difficulty: "Easy",
    question: "You are climbing a staircase. It takes n steps to reach the top. Each time you can climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    hint: "Fibonacci! dp[i] = dp[i-1] + dp[i-2]. Start with dp[1]=1, dp[2]=2.",
    code: `<span class="kw">def</span> <span class="fn">climbStairs</span>(n):
    a, b = <span class="nm">1</span>, <span class="nm">1</span>
    <span class="kw">for</span> _ <span class="kw">in</span> <span class="fn">range</span>(n - <span class="nm">1</span>):
        a, b = b, a + b
    <span class="kw">return</span> b`
  },
  {
    id: 62, lc: 198, title: "House Robber",
    topic: "Dynamic Programming", difficulty: "Medium",
    question: "You are a robber, can't rob two adjacent houses. Given an integer array nums representing the amount of money of each house, return the maximum amount you can rob tonight.",
    hint: "dp[i] = max(dp[i-1], dp[i-2] + nums[i]). Only need prev two values.",
    code: `<span class="kw">def</span> <span class="fn">rob</span>(nums):
    prev2, prev1 = <span class="nm">0</span>, <span class="nm">0</span>
    <span class="kw">for</span> n <span class="kw">in</span> nums:
        prev2, prev1 = prev1, <span class="fn">max</span>(prev1, prev2 + n)
    <span class="kw">return</span> prev1`
  },
  {
    id: 63, lc: 213, title: "House Robber II",
    topic: "Dynamic Programming", difficulty: "Medium",
    question: "Same as House Robber but houses are arranged in a circle (first and last are adjacent). Return the maximum amount you can rob.",
    hint: "Run house robber twice: once on nums[:-1], once on nums[1:]. Return the max.",
    code: `<span class="kw">def</span> <span class="fn">rob</span>(nums):
    <span class="kw">def</span> <span class="fn">rob1</span>(a):
        p2 = p1 = <span class="nm">0</span>
        <span class="kw">for</span> n <span class="kw">in</span> a: p2, p1 = p1, <span class="fn">max</span>(p1, p2+n)
        <span class="kw">return</span> p1
    <span class="kw">return</span> <span class="fn">max</span>(nums[<span class="nm">0</span>], <span class="fn">rob1</span>(nums[:-<span class="nm">1</span>]), <span class="fn">rob1</span>(nums[<span class="nm">1</span>:]))`
  },
  {
    id: 64, lc: 5, title: "Longest Palindromic Substring",
    topic: "Dynamic Programming", difficulty: "Medium",
    question: "Given a string s, return the longest palindromic substring in s.",
    hint: "Expand around center for each character (odd) and each pair (even). Track max.",
    code: `<span class="kw">def</span> <span class="fn">longestPalindrome</span>(s):
    res, rlen = <span class="st">""</span>, <span class="nm">0</span>
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(s)):
        <span class="kw">for</span> l, r <span class="kw">in</span> [(i,i), (i,i+<span class="nm">1</span>)]:
            <span class="kw">while</span> l >= <span class="nm">0</span> <span class="kw">and</span> r < <span class="fn">len</span>(s) <span class="kw">and</span> s[l] == s[r]:
                <span class="kw">if</span> r - l + <span class="nm">1</span> > rlen:
                    res, rlen = s[l:r+<span class="nm">1</span>], r - l + <span class="nm">1</span>
                l -= <span class="nm">1</span>; r += <span class="nm">1</span>
    <span class="kw">return</span> res`
  },
  {
    id: 65, lc: 91, title: "Decode Ways",
    topic: "Dynamic Programming", difficulty: "Medium",
    question: "A message is encoded where 'A'‚Üí1, 'B'‚Üí2, ..., 'Z'‚Üí26. Given a string of digits, return the number of ways to decode it.",
    hint: "dp[i] = ways ending at i. Add dp[i-1] if single digit valid, dp[i-2] if two-digit valid.",
    code: `<span class="kw">def</span> <span class="fn">numDecodings</span>(s):
    dp = {<span class="fn">len</span>(s): <span class="nm">1</span>}
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(s) - <span class="nm">1</span>, -<span class="nm">1</span>, -<span class="nm">1</span>):
        <span class="kw">if</span> s[i] == <span class="st">'0'</span>: dp[i] = <span class="nm">0</span>
        <span class="kw">else</span>: dp[i] = dp[i + <span class="nm">1</span>]
        <span class="kw">if</span> i + <span class="nm">1</span> < <span class="fn">len</span>(s) <span class="kw">and</span> (
            s[i] == <span class="st">'1'</span> <span class="kw">or</span> (s[i] == <span class="st">'2'</span> <span class="kw">and</span> s[i+<span class="nm">1</span>] <span class="kw">in</span> <span class="st">'0123456'</span>)):
            dp[i] += dp[i + <span class="nm">2</span>]
    <span class="kw">return</span> dp[<span class="nm">0</span>]`
  },
  {
    id: 66, lc: 322, title: "Coin Change",
    topic: "Dynamic Programming", difficulty: "Medium",
    question: "Given coins of different denominations and an amount, compute the fewest number of coins needed to make up that amount. Return -1 if not possible.",
    hint: "BFS for shortest path, or DP: dp[i] = min coins for amount i.",
    code: `<span class="kw">def</span> <span class="fn">coinChange</span>(coins, amount):
    dp = [amount + <span class="nm">1</span>] * (amount + <span class="nm">1</span>)
    dp[<span class="nm">0</span>] = <span class="nm">0</span>
    <span class="kw">for</span> a <span class="kw">in</span> <span class="fn">range</span>(<span class="nm">1</span>, amount + <span class="nm">1</span>):
        <span class="kw">for</span> c <span class="kw">in</span> coins:
            <span class="kw">if</span> a >= c:
                dp[a] = <span class="fn">min</span>(dp[a], dp[a - c] + <span class="nm">1</span>)
    <span class="kw">return</span> dp[amount] <span class="kw">if</span> dp[amount] <= amount <span class="kw">else</span> -<span class="nm">1</span>`
  },
  {
    id: 67, lc: 139, title: "Word Break",
    topic: "Dynamic Programming", difficulty: "Medium",
    question: "Given a string s and a dictionary wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.",
    hint: "dp[i] = can form s[:i]. For each i, check all j where dp[j] and s[j:i] is in dict.",
    code: `<span class="kw">def</span> <span class="fn">wordBreak</span>(s, wordDict):
    n = <span class="fn">len</span>(s)
    ws = <span class="fn">set</span>(wordDict)
    dp = [<span class="kw">False</span>] * (n + <span class="nm">1</span>); dp[<span class="nm">0</span>] = <span class="kw">True</span>
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="nm">1</span>, n + <span class="nm">1</span>):
        <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(i):
            <span class="kw">if</span> dp[j] <span class="kw">and</span> s[j:i] <span class="kw">in</span> ws:
                dp[i] = <span class="kw">True</span>; <span class="kw">break</span>
    <span class="kw">return</span> dp[n]`
  },
  {
    id: 68, lc: 300, title: "Longest Increasing Subsequence",
    topic: "Dynamic Programming", difficulty: "Medium",
    question: "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
    hint: "O(n log n): maintain sorted tails array. Binary search to find insertion point.",
    code: `<span class="kw">import</span> bisect
<span class="kw">def</span> <span class="fn">lengthOfLIS</span>(nums):
    tails = []
    <span class="kw">for</span> n <span class="kw">in</span> nums:
        i = bisect.bisect_left(tails, n)
        <span class="kw">if</span> i == <span class="fn">len</span>(tails): tails.append(n)
        <span class="kw">else</span>: tails[i] = n
    <span class="kw">return</span> <span class="fn">len</span>(tails)`
  },
  {
    id: 69, lc: 62, title: "Unique Paths",
    topic: "Dynamic Programming", difficulty: "Medium",
    question: "A robot is on the top-left corner of an m√ón grid. It can only move right or down. How many unique paths are there to reach the bottom-right corner?",
    hint: "dp[i][j] = dp[i-1][j] + dp[i][j-1]. Or use math: C(m+n-2, m-1).",
    code: `<span class="kw">def</span> <span class="fn">uniquePaths</span>(m, n):
    dp = [<span class="nm">1</span>] * n
    <span class="kw">for</span> _ <span class="kw">in</span> <span class="fn">range</span>(<span class="nm">1</span>, m):
        <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(<span class="nm">1</span>, n):
            dp[j] += dp[j - <span class="nm">1</span>]
    <span class="kw">return</span> dp[-<span class="nm">1</span>]`
  },
  {
    id: 70, lc: 55, title: "Jump Game",
    topic: "Dynamic Programming", difficulty: "Medium",
    question: "Given an integer array nums where nums[i] is the maximum jump length at position i. Return true if you can reach the last index starting from index 0.",
    hint: "Greedy: track max reachable index. If i > max_reach at any point, return False.",
    code: `<span class="kw">def</span> <span class="fn">canJump</span>(nums):
    goal = <span class="fn">len</span>(nums) - <span class="nm">1</span>
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(nums) - <span class="nm">2</span>, -<span class="nm">1</span>, -<span class="nm">1</span>):
        <span class="kw">if</span> i + nums[i] >= goal:
            goal = i
    <span class="kw">return</span> goal == <span class="nm">0</span>`
  },
  {
    id: 71, lc: 45, title: "Jump Game II",
    topic: "Dynamic Programming", difficulty: "Medium",
    question: "Given an array of non-negative integers nums, return the minimum number of jumps to reach the last index (guaranteed reachable).",
    hint: "Greedy BFS: track current window end and max reachable. Increment jumps when reaching window end.",
    code: `<span class="kw">def</span> <span class="fn">jump</span>(nums):
    jumps = cur_end = cur_far = <span class="nm">0</span>
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(nums) - <span class="nm">1</span>):
        cur_far = <span class="fn">max</span>(cur_far, i + nums[i])
        <span class="kw">if</span> i == cur_end:
            jumps += <span class="nm">1</span>; cur_end = cur_far
    <span class="kw">return</span> jumps`
  },
  {
    id: 72, lc: 416, title: "Partition Equal Subset Sum",
    topic: "Dynamic Programming", difficulty: "Medium",
    question: "Given a non-empty array nums of positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.",
    hint: "Subset sum problem. Target = total/2. Use a set of achievable sums.",
    code: `<span class="kw">def</span> <span class="fn">canPartition</span>(nums):
    s = <span class="fn">sum</span>(nums)
    <span class="kw">if</span> s % <span class="nm">2</span>: <span class="kw">return False</span>
    target = s // <span class="nm">2</span>
    dp = {<span class="nm">0</span>}
    <span class="kw">for</span> n <span class="kw">in</span> nums:
        dp = {s + n <span class="kw">for</span> s <span class="kw">in</span> dp} | dp
        <span class="kw">if</span> target <span class="kw">in</span> dp: <span class="kw">return True</span>
    <span class="kw">return False</span>`
  },
  {
    id: 73, lc: 72, title: "Edit Distance",
    topic: "Dynamic Programming", difficulty: "Hard",
    question: "Given two strings word1 and word2, return the minimum number of operations (insert, delete, replace) required to convert word1 to word2.",
    hint: "Classic 2D DP. dp[i][j] = edit distance of word1[:i] and word2[:j].",
    code: `<span class="kw">def</span> <span class="fn">minDistance</span>(w1, w2):
    m, n = <span class="fn">len</span>(w1), <span class="fn">len</span>(w2)
    dp = <span class="fn">list</span>(<span class="fn">range</span>(n + <span class="nm">1</span>))
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="nm">1</span>, m + <span class="nm">1</span>):
        prev = dp[<span class="nm">0</span>]; dp[<span class="nm">0</span>] = i
        <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(<span class="nm">1</span>, n + <span class="nm">1</span>):
            tmp = dp[j]
            <span class="kw">if</span> w1[i-<span class="nm">1</span>] == w2[j-<span class="nm">1</span>]: dp[j] = prev
            <span class="kw">else</span>: dp[j] = <span class="nm">1</span> + <span class="fn">min</span>(prev, dp[j], dp[j-<span class="nm">1</span>])
            prev = tmp
    <span class="kw">return</span> dp[n]`
  },
  {
    id: 74, lc: 494, title: "Target Sum",
    topic: "Dynamic Programming", difficulty: "Medium",
    question: "You are given an integer array nums and an integer target. You can assign '+' or '-' to each number. Return the number of different expressions that evaluate to target.",
    hint: "DFS with memoization on (index, current_sum). Or convert to subset sum.",
    code: `<span class="kw">from</span> functools <span class="kw">import</span> lru_cache
<span class="kw">def</span> <span class="fn">findTargetSumWays</span>(nums, target):
    @lru_cache(maxsize=<span class="kw">None</span>)
    <span class="kw">def</span> <span class="fn">dp</span>(i, s):
        <span class="kw">if</span> i == <span class="fn">len</span>(nums): <span class="kw">return</span> <span class="nm">1</span> <span class="kw">if</span> s == target <span class="kw">else</span> <span class="nm">0</span>
        <span class="kw">return</span> <span class="fn">dp</span>(i+<span class="nm">1</span>, s+nums[i]) + <span class="fn">dp</span>(i+<span class="nm">1</span>, s-nums[i])
    <span class="kw">return</span> <span class="fn">dp</span>(<span class="nm">0</span>, <span class="nm">0</span>)`
  },
  {
    id: 75, lc: 647, title: "Palindromic Substrings",
    topic: "Dynamic Programming", difficulty: "Medium",
    question: "Given a string s, return the number of palindromic substrings in it.",
    hint: "Expand around each center (odd + even). Count valid expansions.",
    code: `<span class="kw">def</span> <span class="fn">countSubstrings</span>(s):
    count = <span class="nm">0</span>
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(s)):
        <span class="kw">for</span> l, r <span class="kw">in</span> [(i,i), (i,i+<span class="nm">1</span>)]:
            <span class="kw">while</span> l >= <span class="nm">0</span> <span class="kw">and</span> r < <span class="fn">len</span>(s) <span class="kw">and</span> s[l] == s[r]:
                count += <span class="nm">1</span>; l -= <span class="nm">1</span>; r += <span class="nm">1</span>
    <span class="kw">return</span> count`
  },
  // ‚îÄ‚îÄ Heap ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  {
    id: 76, lc: 295, title: "Find Median from Data Stream",
    topic: "Heap", difficulty: "Hard",
    question: "The MedianFinder class should support: addNum(int num) and findMedian() which returns the median of all elements so far. Must be efficient.",
    hint: "Two heaps: max-heap for lower half, min-heap for upper half. Balance them.",
    code: `<span class="kw">import</span> heapq
<span class="kw">class</span> <span class="fn">MedianFinder</span>:
    <span class="kw">def</span> <span class="fn">__init__</span>(self):
        self.lo = []  <span class="cm"># max-heap (negate)</span>
        self.hi = []  <span class="cm"># min-heap</span>
    <span class="kw">def</span> <span class="fn">addNum</span>(self, num):
        heapq.heappush(self.lo, -num)
        heapq.heappush(self.hi, -heapq.heappop(self.lo))
        <span class="kw">if</span> <span class="fn">len</span>(self.hi) > <span class="fn">len</span>(self.lo):
            heapq.heappush(self.lo, -heapq.heappop(self.hi))
    <span class="kw">def</span> <span class="fn">findMedian</span>(self):
        <span class="kw">if</span> <span class="fn">len</span>(self.lo) > <span class="fn">len</span>(self.hi):
            <span class="kw">return</span> -self.lo[<span class="nm">0</span>]
        <span class="kw">return</span> (-self.lo[<span class="nm">0</span>] + self.hi[<span class="nm">0</span>]) / <span class="nm">2</span>`
  },
  {
    id: 77, lc: 347, title: "Top K Frequent Elements",
    topic: "Heap", difficulty: "Medium",
    question: "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",
    hint: "Count frequencies with Counter. Use bucket sort (index=freq) or heap of size k.",
    code: `<span class="kw">from</span> collections <span class="kw">import</span> Counter
<span class="kw">def</span> <span class="fn">topKFrequent</span>(nums, k):
    count = Counter(nums)
    buckets = [[] <span class="kw">for</span> _ <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(nums) + <span class="nm">1</span>)]
    <span class="kw">for</span> n, c <span class="kw">in</span> count.items(): buckets[c].append(n)
    res = []
    <span class="kw">for</span> b <span class="kw">in</span> reversed(buckets):
        res.extend(b)
        <span class="kw">if</span> <span class="fn">len</span>(res) >= k: <span class="kw">return</span> res[:k]`
  },
  {
    id: 78, lc: 215, title: "Kth Largest Element in an Array",
    topic: "Heap", difficulty: "Medium",
    question: "Given an integer array nums and an integer k, return the kth largest element in the array (not kth distinct element).",
    hint: "Quickselect O(n) average, or min-heap of size k.",
    code: `<span class="kw">import</span> heapq
<span class="kw">def</span> <span class="fn">findKthLargest</span>(nums, k):
    heap = nums[:k]
    heapq.heapify(heap)
    <span class="kw">for</span> n <span class="kw">in</span> nums[k:]:
        <span class="kw">if</span> n > heap[<span class="nm">0</span>]:
            heapq.heapreplace(heap, n)
    <span class="kw">return</span> heap[<span class="nm">0</span>]`
  },
  {
    id: 79, lc: 621, title: "Task Scheduler",
    topic: "Heap", difficulty: "Medium",
    question: "Given a list of tasks with a cooldown n between same task types, return the minimum intervals the CPU needs to finish all tasks.",
    hint: "Max-heap of frequencies. Simulate: execute, decrement, cooldown. Use queue for cooldown tracking.",
    code: `<span class="kw">from</span> collections <span class="kw">import</span> Counter, deque
<span class="kw">import</span> heapq
<span class="kw">def</span> <span class="fn">leastInterval</span>(tasks, n):
    cnt = Counter(tasks)
    heap = [-c <span class="kw">for</span> c <span class="kw">in</span> cnt.values()]
    heapq.heapify(heap)
    q, time = deque(), <span class="nm">0</span>
    <span class="kw">while</span> heap <span class="kw">or</span> q:
        time += <span class="nm">1</span>
        <span class="kw">if</span> heap:
            c = heapq.heappop(heap) + <span class="nm">1</span>
            <span class="kw">if</span> c < <span class="nm">0</span>: q.append((c, time + n))
        <span class="kw">if</span> q <span class="kw">and</span> q[<span class="nm">0</span>][<span class="nm">1</span>] == time:
            heapq.heappush(heap, q.popleft()[<span class="nm">0</span>])
    <span class="kw">return</span> time`
  },
  {
    id: 80, lc: 973, title: "K Closest Points to Origin",
    topic: "Heap", difficulty: "Medium",
    question: "Given an array of points where points[i] = [xi, yi], return the k closest points to the origin (0, 0). The answer is guaranteed to be unique.",
    hint: "Use a max-heap of size k. Distance = x¬≤ + y¬≤ (no sqrt needed).",
    code: `<span class="kw">import</span> heapq
<span class="kw">def</span> <span class="fn">kClosest</span>(points, k):
    heap = []
    <span class="kw">for</span> x, y <span class="kw">in</span> points:
        d = -(x*x + y*y)
        <span class="kw">if</span> <span class="fn">len</span>(heap) == k:
            heapq.heappushpop(heap, (d, x, y))
        <span class="kw">else</span>:
            heapq.heappush(heap, (d, x, y))
    <span class="kw">return</span> [[x, y] <span class="kw">for</span> _, x, y <span class="kw">in</span> heap]`
  },
  // ‚îÄ‚îÄ Backtracking ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  {
    id: 81, lc: 78, title: "Subsets",
    topic: "Backtracking", difficulty: "Medium",
    question: "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets.",
    hint: "Backtrack: at each step include or exclude current element. Or iterate and add element to all existing subsets.",
    code: `<span class="kw">def</span> <span class="fn">subsets</span>(nums):
    res = []
    <span class="kw">def</span> <span class="fn">bt</span>(start, cur):
        res.append(<span class="fn">list</span>(cur))
        <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(start, <span class="fn">len</span>(nums)):
            cur.append(nums[i])
            <span class="fn">bt</span>(i + <span class="nm">1</span>, cur)
            cur.pop()
    <span class="fn">bt</span>(<span class="nm">0</span>, [])
    <span class="kw">return</span> res`
  },
  {
    id: 82, lc: 39, title: "Combination Sum",
    topic: "Backtracking", difficulty: "Medium",
    question: "Given an array of distinct integers candidates and a target integer target, return all unique combinations of candidates where the chosen numbers sum to target. Same number may be chosen unlimited times.",
    hint: "Backtrack. At each step, try including current element again or move to next.",
    code: `<span class="kw">def</span> <span class="fn">combinationSum</span>(candidates, target):
    res = []
    <span class="kw">def</span> <span class="fn">bt</span>(start, cur, rem):
        <span class="kw">if</span> rem == <span class="nm">0</span>: res.append(<span class="fn">list</span>(cur)); <span class="kw">return</span>
        <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(start, <span class="fn">len</span>(candidates)):
            <span class="kw">if</span> candidates[i] <= rem:
                cur.append(candidates[i])
                <span class="fn">bt</span>(i, cur, rem - candidates[i])
                cur.pop()
    <span class="fn">bt</span>(<span class="nm">0</span>, [], target)
    <span class="kw">return</span> res`
  },
  {
    id: 83, lc: 46, title: "Permutations",
    topic: "Backtracking", difficulty: "Medium",
    question: "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
    hint: "Swap-based backtracking or track used elements. Build up permutation, backtrack.",
    code: `<span class="kw">def</span> <span class="fn">permute</span>(nums):
    res = []
    <span class="kw">def</span> <span class="fn">bt</span>(cur, left):
        <span class="kw">if not</span> left: res.append(cur); <span class="kw">return</span>
        <span class="kw">for</span> i, n <span class="kw">in</span> <span class="fn">enumerate</span>(left):
            <span class="fn">bt</span>(cur + [n], left[:i] + left[i+<span class="nm">1</span>:])
    <span class="fn">bt</span>([], nums)
    <span class="kw">return</span> res`
  },
  {
    id: 84, lc: 51, title: "N-Queens",
    topic: "Backtracking", difficulty: "Hard",
    question: "The n-queens puzzle is the problem of placing n queens on an n√ón chessboard such that no two queens attack each other. Return all distinct solutions.",
    hint: "Track col, positive diagonal, and negative diagonal sets. Backtrack row by row.",
    code: `<span class="kw">def</span> <span class="fn">solveNQueens</span>(n):
    col, pos_d, neg_d = <span class="fn">set</span>(), <span class="fn">set</span>(), <span class="fn">set</span>()
    board = [[<span class="st">'.'</span>] * n <span class="kw">for</span> _ <span class="kw">in</span> <span class="fn">range</span>(n)]
    res = []
    <span class="kw">def</span> <span class="fn">bt</span>(r):
        <span class="kw">if</span> r == n: res.append([<span class="st">""</span>.join(row) <span class="kw">for</span> row <span class="kw">in</span> board]); <span class="kw">return</span>
        <span class="kw">for</span> c <span class="kw">in</span> <span class="fn">range</span>(n):
            <span class="kw">if</span> c <span class="kw">in</span> col <span class="kw">or</span> r+c <span class="kw">in</span> pos_d <span class="kw">or</span> r-c <span class="kw">in</span> neg_d: <span class="kw">continue</span>
            col.add(c); pos_d.add(r+c); neg_d.add(r-c)
            board[r][c] = <span class="st">'Q'</span>; <span class="fn">bt</span>(r+<span class="nm">1</span>); board[r][c] = <span class="st">'.'</span>
            col.discard(c); pos_d.discard(r+c); neg_d.discard(r-c)
    <span class="fn">bt</span>(<span class="nm">0</span>); <span class="kw">return</span> res`
  },
  {
    id: 85, lc: 131, title: "Palindrome Partitioning",
    topic: "Backtracking", difficulty: "Medium",
    question: "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.",
    hint: "Backtrack: at each position, try all substrings. If palindrome, recurse on remainder.",
    code: `<span class="kw">def</span> <span class="fn">partition</span>(s):
    res = []
    <span class="kw">def</span> <span class="fn">bt</span>(start, cur):
        <span class="kw">if</span> start == <span class="fn">len</span>(s): res.append(<span class="fn">list</span>(cur)); <span class="kw">return</span>
        <span class="kw">for</span> end <span class="kw">in</span> <span class="fn">range</span>(start + <span class="nm">1</span>, <span class="fn">len</span>(s) + <span class="nm">1</span>):
            sub = s[start:end]
            <span class="kw">if</span> sub == sub[:<span class="nm">:-1</span>]:
                cur.append(sub); <span class="fn">bt</span>(end, cur); cur.pop()
    <span class="fn">bt</span>(<span class="nm">0</span>, [])
    <span class="kw">return</span> res`
  },
  // ‚îÄ‚îÄ Trie ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  {
    id: 86, lc: 208, title: "Implement Trie (Prefix Tree)",
    topic: "Trie", difficulty: "Medium",
    question: "A trie is a tree data structure used to retrieve keys in a string dataset. Implement the Trie class with insert(word), search(word), and startsWith(prefix) methods.",
    hint: "Node has children dict and is_end flag. Walk characters, create nodes as needed.",
    code: `<span class="kw">class</span> <span class="fn">Trie</span>:
    <span class="kw">def</span> <span class="fn">__init__</span>(self):
        self.root = {}
    <span class="kw">def</span> <span class="fn">insert</span>(self, word):
        node = self.root
        <span class="kw">for</span> c <span class="kw">in</span> word: node = node.setdefault(c, {})
        node[<span class="st">'#'</span>] = <span class="kw">True</span>
    <span class="kw">def</span> <span class="fn">search</span>(self, word):
        node = self.root
        <span class="kw">for</span> c <span class="kw">in</span> word:
            <span class="kw">if</span> c <span class="kw">not in</span> node: <span class="kw">return False</span>
            node = node[c]
        <span class="kw">return</span> <span class="st">'#'</span> <span class="kw">in</span> node
    <span class="kw">def</span> <span class="fn">startsWith</span>(self, prefix):
        node = self.root
        <span class="kw">for</span> c <span class="kw">in</span> prefix:
            <span class="kw">if</span> c <span class="kw">not in</span> node: <span class="kw">return False</span>
            node = node[c]
        <span class="kw">return True</span>`
  },
  {
    id: 87, lc: 211, title: "Design Add and Search Words Data Structure",
    topic: "Trie", difficulty: "Medium",
    question: "Design a data structure that supports addWord(word) and search(word) where search can contain '.' as a wildcard matching any letter.",
    hint: "Trie with DFS for '.' wildcard. When '.' is encountered, recurse into all children.",
    code: `<span class="kw">class</span> <span class="fn">WordDictionary</span>:
    <span class="kw">def</span> <span class="fn">__init__</span>(self): self.root = {}
    <span class="kw">def</span> <span class="fn">addWord</span>(self, word):
        node = self.root
        <span class="kw">for</span> c <span class="kw">in</span> word: node = node.setdefault(c, {})
        node[<span class="st">'#'</span>] = <span class="kw">True</span>
    <span class="kw">def</span> <span class="fn">search</span>(self, word):
        <span class="kw">def</span> <span class="fn">dfs</span>(j, node):
            <span class="kw">if</span> j == <span class="fn">len</span>(word): <span class="kw">return</span> <span class="st">'#'</span> <span class="kw">in</span> node
            c = word[j]
            <span class="kw">if</span> c == <span class="st">'.'</span>:
                <span class="kw">return any</span>(<span class="fn">dfs</span>(j+<span class="nm">1</span>, node[k]) <span class="kw">for</span> k <span class="kw">in</span> node <span class="kw">if</span> k != <span class="st">'#'</span>)
            <span class="kw">return</span> c <span class="kw">in</span> node <span class="kw">and</span> <span class="fn">dfs</span>(j+<span class="nm">1</span>, node[c])
        <span class="kw">return</span> <span class="fn">dfs</span>(<span class="nm">0</span>, self.root)`
  },
  {
    id: 88, lc: 212, title: "Word Search II",
    topic: "Trie", difficulty: "Hard",
    question: "Given an m√ón board of characters and a list of strings words, return all words on the board. Words must be constructed from sequentially adjacent cells (no reuse).",
    hint: "Build a Trie from all words. DFS on board, walk the Trie simultaneously. Prune by removing found words.",
    code: `<span class="kw">def</span> <span class="fn">findWords</span>(board, words):
    root = {}
    <span class="kw">for</span> w <span class="kw">in</span> words:
        node = root
        <span class="kw">for</span> c <span class="kw">in</span> w: node = node.setdefault(c, {})
        node[<span class="st">'$'</span>] = w
    m, n, res = <span class="fn">len</span>(board), <span class="fn">len</span>(board[<span class="nm">0</span>]), []
    <span class="kw">def</span> <span class="fn">dfs</span>(i, j, node):
        c = board[i][j]
        <span class="kw">if</span> c <span class="kw">not in</span> node: <span class="kw">return</span>
        nxt = node[c]
        <span class="kw">if</span> <span class="st">'$'</span> <span class="kw">in</span> nxt: res.append(nxt.pop(<span class="st">'$'</span>))
        board[i][j] = <span class="st">'#'</span>
        <span class="kw">for</span> di, dj <span class="kw">in</span> [(<span class="nm">1</span>,<span class="nm">0</span>),(-<span class="nm">1</span>,<span class="nm">0</span>),(<span class="nm">0</span>,<span class="nm">1</span>),(<span class="nm">0</span>,-<span class="nm">1</span>)]:
            ni, nj = i+di, j+dj
            <span class="kw">if</span> <span class="nm">0</span><=ni<m <span class="kw">and</span> <span class="nm">0</span><=nj<n: <span class="fn">dfs</span>(ni, nj, nxt)
        board[i][j] = c
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(m):
        <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(n): <span class="fn">dfs</span>(i, j, root)
    <span class="kw">return</span> res`
  },
  // ‚îÄ‚îÄ Sliding Window continued ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  {
    id: 89, lc: 239, title: "Sliding Window Maximum",
    topic: "Sliding Window", difficulty: "Hard",
    question: "You are given an array of integers nums, there is a sliding window of size k moving from left to right. Return the max sliding window (maximum of each window).",
    hint: "Use a monotonic deque (decreasing). Deque front is always the max.",
    code: `<span class="kw">from</span> collections <span class="kw">import</span> deque
<span class="kw">def</span> <span class="fn">maxSlidingWindow</span>(nums, k):
    dq, res = deque(), []
    <span class="kw">for</span> i, n <span class="kw">in</span> <span class="fn">enumerate</span>(nums):
        <span class="kw">while</span> dq <span class="kw">and</span> nums[dq[-<span class="nm">1</span>]] <= n: dq.pop()
        dq.append(i)
        <span class="kw">if</span> dq[<span class="nm">0</span>] == i - k: dq.popleft()
        <span class="kw">if</span> i >= k - <span class="nm">1</span>: res.append(nums[dq[<span class="nm">0</span>]])
    <span class="kw">return</span> res`
  },
  // ‚îÄ‚îÄ Bonus / Extra ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  {
    id: 90, lc: 647, title: "Palindromic Substrings",
    topic: "Dynamic Programming", difficulty: "Medium",
    question: "Given a string s, return the number of palindromic substrings in it. A string is a palindrome when it reads the same backward as forward.",
    hint: "Expand around every center (character or gap). O(n¬≤).",
    code: `<span class="kw">def</span> <span class="fn">countSubstrings</span>(s):
    count = <span class="nm">0</span>
    <span class="kw">for</span> center <span class="kw">in</span> <span class="fn">range</span>(<span class="nm">2</span> * <span class="fn">len</span>(s) - <span class="nm">1</span>):
        l = center // <span class="nm">2</span>
        r = l + center % <span class="nm">2</span>
        <span class="kw">while</span> l >= <span class="nm">0</span> <span class="kw">and</span> r < <span class="fn">len</span>(s) <span class="kw">and</span> s[l] == s[r]:
            count += <span class="nm">1</span>; l -= <span class="nm">1</span>; r += <span class="nm">1</span>
    <span class="kw">return</span> count`
  },
  {
    id: 91, lc: 355, title: "Design Twitter",
    topic: "Heap", difficulty: "Medium",
    question: "Design a simplified version of Twitter where users can post tweets, follow/unfollow each other, and see the 10 most recent tweets in their news feed (self + followees).",
    hint: "Store tweets as (timestamp, tweetId) per user. News feed: merge-k-sorted using heap.",
    code: `<span class="kw">import</span> heapq
<span class="kw">from</span> collections <span class="kw">import</span> defaultdict
<span class="kw">class</span> <span class="fn">Twitter</span>:
    <span class="kw">def</span> <span class="fn">__init__</span>(self):
        self.t = <span class="nm">0</span>
        self.tweets = defaultdict(<span class="fn">list</span>)
        self.following = defaultdict(<span class="fn">set</span>)
    <span class="kw">def</span> <span class="fn">postTweet</span>(self, uid, tid):
        self.tweets[uid].append((self.t, tid)); self.t -= <span class="nm">1</span>
    <span class="kw">def</span> <span class="fn">getNewsFeed</span>(self, uid):
        heap = []
        <span class="kw">for</span> u <span class="kw">in</span> self.following[uid] | {uid}:
            ts = self.tweets[u]
            <span class="kw">if</span> ts: heapq.heappush(heap, (ts[-<span class="nm">1</span>][<span class="nm">0</span>], ts[-<span class="nm">1</span>][<span class="nm">1</span>], u, <span class="fn">len</span>(ts)-<span class="nm">1</span>))
        res = []
        <span class="kw">while</span> heap <span class="kw">and</span> <span class="fn">len</span>(res) < <span class="nm">10</span>:
            t, tid, u, i = heapq.heappop(heap)
            res.append(tid)
            <span class="kw">if</span> i > <span class="nm">0</span>: heapq.heappush(heap, (self.tweets[u][i-<span class="nm">1</span>][<span class="nm">0</span>], self.tweets[u][i-<span class="nm">1</span>][<span class="nm">1</span>], u, i-<span class="nm">1</span>))
        <span class="kw">return</span> res
    <span class="kw">def</span> <span class="fn">follow</span>(self, f, e): self.following[f].add(e)
    <span class="kw">def</span> <span class="fn">unfollow</span>(self, f, e): self.following[f].discard(e)`
  },
  {
    id: 92, lc: 10, title: "Regular Expression Matching",
    topic: "Dynamic Programming", difficulty: "Hard",
    question: "Given an input string s and a pattern p, implement regular expression matching with '.' (matches any single character) and '*' (matches zero or more of the preceding element).",
    hint: "2D DP. dp[i][j] = does s[:i] match p[:j]? Handle '*' by skipping pair or consuming s char.",
    code: `<span class="kw">def</span> <span class="fn">isMatch</span>(s, p):
    m, n = <span class="fn">len</span>(s), <span class="fn">len</span>(p)
    dp = [[<span class="kw">False</span>]*(n+<span class="nm">1</span>) <span class="kw">for</span> _ <span class="kw">in</span> <span class="fn">range</span>(m+<span class="nm">1</span>)]
    dp[<span class="nm">0</span>][<span class="nm">0</span>] = <span class="kw">True</span>
    <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(<span class="nm">2</span>, n+<span class="nm">1</span>):
        <span class="kw">if</span> p[j-<span class="nm">1</span>] == <span class="st">'*'</span>: dp[<span class="nm">0</span>][j] = dp[<span class="nm">0</span>][j-<span class="nm">2</span>]
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="nm">1</span>, m+<span class="nm">1</span>):
        <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(<span class="nm">1</span>, n+<span class="nm">1</span>):
            <span class="kw">if</span> p[j-<span class="nm">1</span>] == <span class="st">'*'</span>:
                dp[i][j] = dp[i][j-<span class="nm">2</span>]
                <span class="kw">if</span> p[j-<span class="nm">2</span>] <span class="kw">in</span> (s[i-<span class="nm">1</span>], <span class="st">'.'</span>):
                    dp[i][j] = dp[i][j] <span class="kw">or</span> dp[i-<span class="nm">1</span>][j]
            <span class="kw">elif</span> p[j-<span class="nm">1</span>] <span class="kw">in</span> (s[i-<span class="nm">1</span>], <span class="st">'.'</span>):
                dp[i][j] = dp[i-<span class="nm">1</span>][j-<span class="nm">1</span>]
    <span class="kw">return</span> dp[m][n]`
  },
  {
    id: 93, lc: 312, title: "Burst Balloons",
    topic: "Dynamic Programming", difficulty: "Hard",
    question: "Given n balloons indexed 0 to n-1 with values, burst all balloons to maximize coins earned. Bursting balloon i earns nums[i-1]*nums[i]*nums[i+1] coins.",
    hint: "Interval DP. dp[l][r] = max coins from bursting all balloons between l and r. Think: which balloon bursts LAST?",
    code: `<span class="kw">def</span> <span class="fn">maxCoins</span>(nums):
    nums = [<span class="nm">1</span>] + nums + [<span class="nm">1</span>]
    n = <span class="fn">len</span>(nums)
    dp = [[<span class="nm">0</span>] * n <span class="kw">for</span> _ <span class="kw">in</span> <span class="fn">range</span>(n)]
    <span class="kw">for</span> length <span class="kw">in</span> <span class="fn">range</span>(<span class="nm">2</span>, n):
        <span class="kw">for</span> l <span class="kw">in</span> <span class="fn">range</span>(<span class="nm">0</span>, n - length):
            r = l + length
            <span class="kw">for</span> k <span class="kw">in</span> <span class="fn">range</span>(l+<span class="nm">1</span>, r):
                dp[l][r] = <span class="fn">max</span>(dp[l][r],
                    dp[l][k] + dp[k][r] + nums[l]*nums[k]*nums[r])
    <span class="kw">return</span> dp[<span class="nm">0</span>][n-<span class="nm">1</span>]`
  },
  {
    id: 94, lc: 97, title: "Interleaving String",
    topic: "Dynamic Programming", difficulty: "Medium",
    question: "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2. An interleaving of two strings preserves their left-to-right order.",
    hint: "dp[i][j] = can s3[:i+j] be formed from s1[:i] and s2[:j]. Optimize with 1D DP.",
    code: `<span class="kw">def</span> <span class="fn">isInterleave</span>(s1, s2, s3):
    m, n = <span class="fn">len</span>(s1), <span class="fn">len</span>(s2)
    <span class="kw">if</span> m + n != <span class="fn">len</span>(s3): <span class="kw">return False</span>
    dp = [<span class="kw">False</span>] * (n + <span class="nm">1</span>)
    dp[<span class="nm">0</span>] = <span class="kw">True</span>
    <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(<span class="nm">1</span>, n + <span class="nm">1</span>):
        dp[j] = dp[j-<span class="nm">1</span>] <span class="kw">and</span> s2[j-<span class="nm">1</span>] == s3[j-<span class="nm">1</span>]
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="nm">1</span>, m + <span class="nm">1</span>):
        dp[<span class="nm">0</span>] = dp[<span class="nm">0</span>] <span class="kw">and</span> s1[i-<span class="nm">1</span>] == s3[i-<span class="nm">1</span>]
        <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(<span class="nm">1</span>, n + <span class="nm">1</span>):
            dp[j] = ((dp[j] <span class="kw">and</span> s1[i-<span class="nm">1</span>] == s3[i+j-<span class="nm">1</span>]) <span class="kw">or</span>
                     (dp[j-<span class="nm">1</span>] <span class="kw">and</span> s2[j-<span class="nm">1</span>] == s3[i+j-<span class="nm">1</span>]))
    <span class="kw">return</span> dp[n]`
  },
  {
    id: 95, lc: 286, title: "Walls and Gates",
    topic: "Graphs", difficulty: "Medium",
    question: "You are given an m√ón grid with -1 (wall), 0 (gate), or INF (empty room). Fill each empty room with the distance to its nearest gate. If unreachable, keep as INF.",
    hint: "Multi-source BFS starting from all gates (0s) simultaneously.",
    code: `<span class="kw">from</span> collections <span class="kw">import</span> deque
<span class="kw">def</span> <span class="fn">wallsAndGates</span>(rooms):
    INF = <span class="nm">2147483647</span>
    m, n = <span class="fn">len</span>(rooms), <span class="fn">len</span>(rooms[<span class="nm">0</span>])
    q = deque([(i,j) <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(m) <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(n) <span class="kw">if</span> rooms[i][j]==<span class="nm">0</span>])
    <span class="kw">while</span> q:
        r, c = q.popleft()
        <span class="kw">for</span> dr, dc <span class="kw">in</span> [(<span class="nm">1</span>,<span class="nm">0</span>),(-<span class="nm">1</span>,<span class="nm">0</span>),(<span class="nm">0</span>,<span class="nm">1</span>),(<span class="nm">0</span>,-<span class="nm">1</span>)]:
            nr, nc = r+dr, c+dc
            <span class="kw">if</span> <span class="nm">0</span><=nr<m <span class="kw">and</span> <span class="nm">0</span><=nc<n <span class="kw">and</span> rooms[nr][nc] == INF:
                rooms[nr][nc] = rooms[r][c] + <span class="nm">1</span>
                q.append((nr, nc))`
  },
  {
    id: 96, lc: 323, title: "Number of Connected Components",
    topic: "Graphs", difficulty: "Medium",
    question: "Given n nodes (0 to n-1) and a list of undirected edges, find the number of connected components in the graph.",
    hint: "Union-Find or BFS/DFS. Count groups where nodes are reachable from each other.",
    code: `<span class="kw">def</span> <span class="fn">countComponents</span>(n, edges):
    parent = <span class="fn">list</span>(<span class="fn">range</span>(n))
    <span class="kw">def</span> <span class="fn">find</span>(x):
        <span class="kw">while</span> parent[x] != x:
            parent[x] = parent[parent[x]]; x = parent[x]
        <span class="kw">return</span> x
    <span class="kw">def</span> <span class="fn">union</span>(a, b):
        pa, pb = <span class="fn">find</span>(a), <span class="fn">find</span>(b)
        <span class="kw">if</span> pa == pb: <span class="kw">return</span> <span class="nm">0</span>
        parent[pa] = pb; <span class="kw">return</span> <span class="nm">1</span>
    <span class="kw">return</span> n - <span class="fn">sum</span>(<span class="fn">union</span>(a, b) <span class="kw">for</span> a, b <span class="kw">in</span> edges)`
  },
  {
    id: 97, lc: 261, title: "Graph Valid Tree",
    topic: "Graphs", difficulty: "Medium",
    question: "Given n nodes and a list of undirected edges, determine if these edges make up a valid tree (connected, no cycles, exactly n-1 edges).",
    hint: "Union-Find: a tree has exactly n-1 edges with no cycle. Or BFS ensuring all nodes visited exactly once.",
    code: `<span class="kw">def</span> <span class="fn">validTree</span>(n, edges):
    <span class="kw">if</span> <span class="fn">len</span>(edges) != n - <span class="nm">1</span>: <span class="kw">return False</span>
    parent = <span class="fn">list</span>(<span class="fn">range</span>(n))
    <span class="kw">def</span> <span class="fn">find</span>(x):
        <span class="kw">while</span> parent[x] != x:
            parent[x] = parent[parent[x]]; x = parent[x]
        <span class="kw">return</span> x
    <span class="kw">for</span> a, b <span class="kw">in</span> edges:
        pa, pb = <span class="fn">find</span>(a), <span class="fn">find</span>(b)
        <span class="kw">if</span> pa == pb: <span class="kw">return False</span>
        parent[pa] = pb
    <span class="kw">return True</span>`
  },
  {
    id: 98, lc: 647, title: "Subsets II (With Duplicates)",
    topic: "Backtracking", difficulty: "Medium",
    question: "Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets.",
    hint: "Sort first. Skip duplicate elements at the same recursion level.",
    code: `<span class="kw">def</span> <span class="fn">subsetsWithDup</span>(nums):
    nums.sort(); res = []
    <span class="kw">def</span> <span class="fn">bt</span>(start, cur):
        res.append(<span class="fn">list</span>(cur))
        <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(start, <span class="fn">len</span>(nums)):
            <span class="kw">if</span> i > start <span class="kw">and</span> nums[i] == nums[i-<span class="nm">1</span>]: <span class="kw">continue</span>
            cur.append(nums[i]); <span class="fn">bt</span>(i+<span class="nm">1</span>, cur); cur.pop()
    <span class="fn">bt</span>(<span class="nm">0</span>, [])
    <span class="kw">return</span> res`
  },
  {
    id: 99, lc: 981, title: "Min Stack",
    topic: "Arrays", difficulty: "Medium",
    question: "Design a stack that supports push, pop, top, and retrieving the minimum element in O(1). Implement MinStack with these four operations.",
    hint: "Keep a second stack that tracks the current minimum at each level.",
    code: `<span class="kw">class</span> <span class="fn">MinStack</span>:
    <span class="kw">def</span> <span class="fn">__init__</span>(self):
        self.stack = []
        self.min_stack = []
    <span class="kw">def</span> <span class="fn">push</span>(self, val):
        self.stack.append(val)
        mn = <span class="fn">min</span>(val, self.min_stack[-<span class="nm">1</span>] <span class="kw">if</span> self.min_stack <span class="kw">else</span> val)
        self.min_stack.append(mn)
    <span class="kw">def</span> <span class="fn">pop</span>(self):
        self.stack.pop(); self.min_stack.pop()
    <span class="kw">def</span> <span class="fn">top</span>(self): <span class="kw">return</span> self.stack[-<span class="nm">1</span>]
    <span class="kw">def</span> <span class="fn">getMin</span>(self): <span class="kw">return</span> self.min_stack[-<span class="nm">1</span>]`
  },
  {
    id: 100, lc: 128, title: "Longest Consecutive Sequence",
    topic: "Arrays", difficulty: "Medium",
    question: "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. Must run in O(n) time.",
    hint: "Put all in a set. For each num that is the start of a sequence (num-1 not in set), count consecutive elements.",
    code: `<span class="kw">def</span> <span class="fn">longestConsecutive</span>(nums):
    num_set = <span class="fn">set</span>(nums)
    best = <span class="nm">0</span>
    <span class="kw">for</span> n <span class="kw">in</span> num_set:
        <span class="kw">if</span> n - <span class="nm">1</span> <span class="kw">not in</span> num_set:
            cur = n; length = <span class="nm">1</span>
            <span class="kw">while</span> cur + <span class="nm">1</span> <span class="kw">in</span> num_set:
                cur += <span class="nm">1</span>; length += <span class="nm">1</span>
            best = <span class="fn">max</span>(best, length)
    <span class="kw">return</span> best`
  },
];

// Mastered state
let mastered = JSON.parse(localStorage.getItem('mastered') || '{}');

function saveMastered() {
  localStorage.setItem('mastered', JSON.stringify(mastered));
}

// Filters
let activeTopics = ['all'];
let activeDiff = 'all';
let activeStatus = 'all';
let searchQuery = '';

function updateStats() {
  const visible = document.querySelectorAll('.card-wrap:not(.hidden)').length;
  const masteredCount = Object.values(mastered).filter(Boolean).length;
  const easyCount = CARDS.filter(c => c.difficulty === 'Easy').length;
  const medCount = CARDS.filter(c => c.difficulty === 'Medium').length;
  const hardCount = CARDS.filter(c => c.difficulty === 'Hard').length;
  
  document.getElementById('visible-count').textContent = visible;
  document.getElementById('mastered-count').textContent = masteredCount;
  document.getElementById('easy-count').textContent = easyCount;
  document.getElementById('med-count').textContent = medCount;
  document.getElementById('hard-count').textContent = hardCount;
  
  const fill = (masteredCount / 100) * 100;
  document.getElementById('progress-fill').style.width = fill + '%';
  document.getElementById('progress-label').textContent = `${masteredCount} / 100`;
}

function filterCards() {
  let shown = 0;
  document.querySelectorAll('.card-wrap').forEach(wrap => {
    const id = parseInt(wrap.dataset.id);
    const card = CARDS.find(c => c.id === id);
    
    const topicMatch = activeTopics.includes('all') || activeTopics.includes(card.topic);
    const diffMatch = activeDiff === 'all' || card.difficulty === activeDiff;
    const statusMatch = activeStatus === 'all'
      || (activeStatus === 'mastered' && mastered[id])
      || (activeStatus === 'unmastered' && !mastered[id]);
    const searchMatch = !searchQuery || 
      card.title.toLowerCase().includes(searchQuery) ||
      card.topic.toLowerCase().includes(searchQuery) ||
      card.difficulty.toLowerCase().includes(searchQuery);
    
    const visible = topicMatch && diffMatch && statusMatch && searchMatch;
    wrap.classList.toggle('hidden', !visible);
    if (visible) shown++;
  });
  
  document.getElementById('empty').style.display = shown === 0 ? 'block' : 'none';
  updateStats();
}

function renderCards() {
  const grid = document.getElementById('card-grid');
  grid.innerHTML = '';
  
  CARDS.forEach((card, idx) => {
    const isMastered = mastered[card.id];
    const wrap = document.createElement('div');
    wrap.className = `card-wrap${isMastered ? ' mastered' : ''}`;
    wrap.dataset.id = card.id;
    wrap.style.animationDelay = (idx * 0.02) + 's';
    
    const diffClass = `tag-${card.difficulty.toLowerCase()}`;
    
    wrap.innerHTML = `
      <div class="card" id="card-${card.id}">
        <div class="card-front">
          <div class="card-meta">
            <span class="card-num">#${card.lc}</span>
            <span class="tag tag-topic">${card.topic}</span>
            <span class="tag ${diffClass}">${card.difficulty}</span>
            <a class="lc-link" href="https://leetcode.com/problems/${card.title.toLowerCase().replace(/[^a-z0-9]+/g,'-')}/" target="_blank">LC ‚Üí</a>
          </div>
          <div class="card-title">${card.title}</div>
          <div class="card-question">${card.question}</div>
          <div class="card-hint">
            <div class="card-hint-label">// hint</div>
            ${card.hint}
          </div>
          <div class="flip-hint">[ click to see solution ]</div>
        </div>
        <div class="card-back">
          <div class="back-header">Python Solution</div>
          <pre>${card.code}</pre>
          <div class="card-actions">
            <button class="action-btn mastered-btn${isMastered ? ' active' : ''}" 
              onclick="toggleMastered(event, ${card.id})">
              ${isMastered ? '‚úì Mastered' : 'Mark Mastered'}
            </button>
            <button class="action-btn flip-btn" onclick="flipCard(event, ${card.id})">Flip Back</button>
          </div>
        </div>
      </div>`;
    
    wrap.addEventListener('click', (e) => {
      if (e.target.closest('button') || e.target.closest('a')) return;
      const cardEl = wrap.querySelector('.card');
      cardEl.classList.toggle('flipped');
    });
    
    grid.appendChild(wrap);
  });
  
  filterCards();
}

function flipCard(e, id) {
  e.stopPropagation();
  document.getElementById('card-' + id).classList.remove('flipped');
}

function toggleMastered(e, id) {
  e.stopPropagation();
  mastered[id] = !mastered[id];
  saveMastered();
  const wrap = document.querySelector(`[data-id="${id}"]`);
  const btn = wrap.querySelector('.mastered-btn');
  wrap.classList.toggle('mastered', mastered[id]);
  btn.classList.toggle('active', mastered[id]);
  btn.textContent = mastered[id] ? '‚úì Mastered' : 'Mark Mastered';
  filterCards();
}

function resetAll() {
  if (!confirm('Reset all progress?')) return;
  mastered = {};
  saveMastered();
  document.querySelectorAll('.card-wrap').forEach(w => {
    w.classList.remove('mastered');
    const btn = w.querySelector('.mastered-btn');
    if (btn) { btn.classList.remove('active'); btn.textContent = 'Mark Mastered'; }
    w.querySelector('.card')?.classList.remove('flipped');
  });
  filterCards();
}

// Topic filter (multi-select)
document.getElementById('topic-filters').addEventListener('click', e => {
  const btn = e.target.closest('.filter-btn');
  if (!btn) return;
  const topic = btn.dataset.topic;
  
  if (topic === 'all') {
    activeTopics = ['all'];
    document.querySelectorAll('#topic-filters .filter-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  } else {
    const allBtn = document.querySelector('#topic-filters [data-topic="all"]');
    allBtn.classList.remove('active');
    activeTopics = activeTopics.filter(t => t !== 'all');
    
    if (activeTopics.includes(topic)) {
      activeTopics = activeTopics.filter(t => t !== topic);
      btn.classList.remove('active');
    } else {
      activeTopics.push(topic);
      btn.classList.add('active');
    }
    
    if (activeTopics.length === 0) {
      activeTopics = ['all'];
      allBtn.classList.add('active');
    }
  }
  filterCards();
});

// Difficulty filter
document.getElementById('diff-filters').addEventListener('click', e => {
  const btn = e.target.closest('.filter-btn');
  if (!btn) return;
  document.querySelectorAll('#diff-filters .filter-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  activeDiff = btn.dataset.diff;
  filterCards();
});

// Status filter
document.getElementById('status-filters').addEventListener('click', e => {
  const btn = e.target.closest('.filter-btn');
  if (!btn) return;
  document.querySelectorAll('#status-filters .filter-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  activeStatus = btn.dataset.status;
  filterCards();
});

// Search
document.getElementById('search').addEventListener('input', e => {
  searchQuery = e.target.value.toLowerCase().trim();
  filterCards();
});

// Scroll to top
window.addEventListener('scroll', () => {
  document.getElementById('scrollTop').classList.toggle('visible', window.scrollY > 400);
});

// Init
renderCards();
</script>
</body>
</html>
